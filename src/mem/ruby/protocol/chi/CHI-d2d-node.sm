/*
 * Copyright (c) 2022 Starfive
 * All rights reserved
 */

machine(MachineType:D2DNode, "CHI interface to the D2D bridge") :

    // CHI network side channels
    MessageBuffer * reqIn,   network="From", virtual_network="0", vnet_type="none";
    MessageBuffer * snpIn,   network="From", virtual_network="1", vnet_type="none";
    MessageBuffer * rspIn,   network="From", virtual_network="2", vnet_type="none";
    MessageBuffer * datIn,   network="From", virtual_network="3", vnet_type="response";

    MessageBuffer * reqOut,   network="To", virtual_network="0", vnet_type="none";
    MessageBuffer * snpOut,   network="To", virtual_network="1", vnet_type="none";
    MessageBuffer * rspOut,   network="To", virtual_network="2", vnet_type="none";
    MessageBuffer * datOut,   network="To", virtual_network="3", vnet_type="response";

    // CHI bridge side channels
    MessageBuffer * d2dnode_reqIn;
    MessageBuffer * d2dnode_snpIn;
    MessageBuffer * d2dnode_rspIn;
    MessageBuffer * d2dnode_datIn;

    MessageBuffer * d2dnode_reqOut;
    MessageBuffer * d2dnode_snpOut;
    MessageBuffer * d2dnode_rspOut;
    MessageBuffer * d2dnode_datOut;

    // Send credits (for back pressure) for d2d node
    MessageBuffer * d2dnode_crdOut;

    // Accepted requests
    MessageBuffer * reqRdy;

    // Accepted snp requests
    MessageBuffer * snpRdy;

    // Trigger queue for internal events
    MessageBuffer * triggerQueue;

    // Internal queue for retry trigger events
    MessageBuffer * retryTriggerQueue;

    // Remap table allocation latency
    int allocation_latency  := 1;

    // Enqueue latencies for outgoing messages
    // NOTE: should remove this and only use parameters above?
    Cycles request_latency := 1;
    Cycles response_latency := 1;
    Cycles snoop_latency := 1;
    Cycles data_latency := 1;

    // Bridge --> NW latencies
    int lat_req_bridge_2_nw := 1;
    int lat_rsp_bridge_2_nw := 1;
    int lat_snp_bridge_2_nw := 1;
    int lat_dat_bridge_2_nw := 1;

    // NW --> Bridge NW latencies
    int lat_req_nw_2_bridge := 1;
    int lat_rsp_nw_2_bridge := 1;
    int lat_snp_nw_2_bridge := 1;
    int lat_dat_nw_2_bridge := 1;

    // Number of REMAP entries
    int num_txremap_entries := 8;
    int num_rxremap_entries := 8;
    int num_txsnp_entries   := 2;

    int data_channel_size;

    int lat_crd_transfer := 1;

    // Src and Dst die Ids
    int src_die_id := 0;
    int dst_die_id := 1;

    // Do you transmit retry from NW or store it
    bool transmit_retry_from_nw;
    
{
    // Cache block size
    int blockSize, default="RubySystem::getBlockSizeBytes()";

    state_declaration(State, default="D2DNode_State_null") {
        // Null state for debugging
        null,         AccessPermission:Invalid,     desc="Null state";
        busy_blkd,    AccessPermission:Invalid,     desc="A tracker entry has been allocated, so the transaction is progress, Cannot accept snps";
        busy_intr,    AccessPermission:Invalid,     desc="A tracker entry has been allocated, so the transaction is progress, Can accept snps";
        stable,       AccessPermission:Invalid,     desc="Stable but invalid, no ongoing transactions";
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Events
    ////////////////////////////////////////////////////////////////////////////
    enumeration(Event) {
        AllocTxReqEntry,            desc="Allocate a Tx Remap entry";
        AllocTxReqEntry_WithCredit, desc="Allocate a Tx Remap entry with credit";

        AllocTxSnpEntry,            desc="Allocate a Tx Snp entry";

        Frm_NW_ReadData,     desc="Dat Rsp to a Read Data from NW";
        Frm_NW_WriteData,    desc="Dat Rsp to a Write Data from NW";
        Frm_NW_SnpData,      desc="Dat Rsp to a Snp Data from NW";

        Frm_d2d_ReadData,    desc="Dat Rsp to a Read Data from d2d";
        Frm_d2d_WriteData,   desc="Dat Rsp to a Write Data from d2d";
        Frm_d2d_SnpData,     desc="Dat Rsp to a Snp Data from d2d";

        Frm_NW_Comp,         desc="Comp Rsp from NW side";
        Frm_NW_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_NW_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_NW_CompAck,      desc="CompAck Rsp from NW side";
        Frm_NW_SnpResp,      desc="SnpRsp from NW side";
        Frm_NW_RetryAck,     desc="RetryAck from NW side";
        Frm_NW_PCrdGrant,    desc="PCrdGrant from NW side";

        Frm_d2d_Request,      desc="Received a request from D2D Side, Fwd to HA";
        Frm_d2d_Snp,          desc="Received a snp request from D2D Side, Fwd to HNF, check the upstream addr";
        Frm_d2d_Comp,         desc="Comp Rsp from NW side";
        Frm_d2d_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_d2d_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_d2d_CompAck,      desc="CompAck Rsp from NW side";
        Frm_d2d_SnpResp,      desc="SnpRsp from NW side";
        Frm_d2d_RetryAck,     desc="RetryAck from NW side";
        Frm_d2d_PCrdGrant,    desc="PCrdGrant from NW side";

        Frm_NW_Req,           desc="Req from NW";
        Frm_NW_Snp,           desc="Snp req from NW";
        
        DeAllocTxReqEntry,   desc="Finalize event";
        DeAllocTxSnpEntry,   desc="Finalize event (For SNP req)";

        // Retry handling
        SendRetryAck,        desc="Send RetryAck";
        SendPCrdGrant,       desc="Send PCrdGrant";
        DoRetryToD2D,        desc="Send the retried request accross";

        null,                desc="";
    }

    ////////////////////////////////////////////////////////////////////////////
    // Structure
    ////////////////////////////////////////////////////////////////////////////

    structure(TriggerMsg, desc="...", interface="Message") {
        Addr        addr;
        Event       event;

        bool functionalRead(Packet *pkt) { return false; }
        bool functionalRead(Packet *pkt, WriteMask &mask) { return false; }
        bool functionalWrite(Packet *pkt) { return false; }
    }

    // Tracks a pending retry
    structure(RetryQueueEntry) {
      Addr addr,           desc="Line address";
      MachineID retryDest, desc="Retry destination";
    }

    structure(TriggerQueue, external ="yes") {
        Event front();
        Event back();
        bool frontNB();
        bool backNB();
        bool empty();
        void push(Event);
        void pushNB(Event);
        void pushFront(Event);
        void pushFrontNB(Event);
        void pop();
        void clear();

        // SLICC does not allow re-using the functions with different template arguments
        void emplace_retry(Addr,MachineID);
        RetryQueueEntry front_retry();
    }

    structure(TBE, desc="Common structure for Tx and Rx Table Entry") {
        State state,              desc="Once allocated, the state must be always busy_blkd";
        Addr addr,                desc="Address corresponding to this request";
        
        /* Extracted from the original REQ messages */
        MachineID o_src_id,          desc="d2d Src Id, Requestor HNF";
        MachineID o_fwd_src_id,      desc="d2d fwd Src Id, Fwd Requestor";
        int storSlot,                desc="Slot in the storage tracker occupied by this entry";
        
        /* Use to construct the retried req message, after receiving the PCrdGrant from D2D*/
        Addr pendReqAccAddr;
        int pendReqAccSize;
        CHIRequestType pendReqType,    desc="Request type";
        bool pendReqRetToSrc,          desc="";
        bool pendReqAllowRetryFromD2D, desc="";

        /* Expecting a CompAck*/
        bool expCompAck,          desc="Does the request a CompAck";

        bool wakeup_pending_req,  desc="This TBE is blocking another request to same addr";
        bool wakeup_pending_snp,  desc="This TBE is blocking another snp request to same addr";

        /* Type of TBE */
        bool is_req_tx,           desc="REQ Tx entry";
        bool is_snp_tx,           desc="SNP Tx entry";

        /* Retry related messages from D2D */
        bool d2d_rcvd_retryack,   desc="RetryAck recvd from the D2D side";
        bool d2d_rcvd_pcrdgrant,  desc="PCrdGrant recvd from the D2D side";

        /* Recvd Data masks */
        WriteMask dataBlkValid,   desc="Marks which bytes in the DataBlock are valid";
        
        // Unused fields to appease the SLICC compiler
        TriggerQueue actions,     template="<D2DNode_Event>", desc="List of actions";
        Event slicchack1,         desc="fix compiler not including headers";
    }

    structure(TBETable, external ="yes") {
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
    }

    structure(TBEStorage, external ="yes") {
        int size();
        int capacity();
        int reserved();
        int addEntryToNewSlot();
        bool areNSlotsAvailable(int n);
        void incrementReserved();
        void decrementReserved();
        void removeEntryFromSlot(int slot);
    }

    // Pending RetryAck/PCrdGrant
    structure(RetryTriggerMsg, interface="Message") {
      Addr addr;
      Event event;
      MachineID retryDest;

      bool functionalRead(Packet *pkt) { return false; }
      bool functionalRead(Packet *pkt, WriteMask &mask) { return false; }
      bool functionalWrite(Packet *pkt) { return false; }
    }

    TBETable TxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_txremap_entries";
    TBEStorage storTxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_txremap_entries";
    
    TBETable TxSnpMapTable,       template="<D2DNode_TBE>",constructor="m_num_txsnp_entries";
    TBEStorage storTxSnpMapTable, constructor="this, TBEType_to_string(TBEType_D2DSnp), m_num_txsnp_entries";

    // Retry handling
    // Destinations that will be sent PCrdGrant when a TBE becomes available
    TriggerQueue retryQueue, template="<D2DNode_RetryQueueEntry>";

    ////////////////////////////////////////////////////////////////////////////
    // Interface functions required by SLICC
    ////////////////////////////////////////////////////////////////////////////
    State getState(TBE tbe, Addr addr) {
        if (is_valid(tbe)) {
            return tbe.state;
        } else {
            return State:stable;
        }
    }

    void setState(TBE tbe, Addr addr, State state) {
        if (is_valid(tbe)) {
            tbe.state := state;
        }
    }
    
    void setAccessPermission(Addr txnId, State state) {}

    AccessPermission getAccessPermission(Addr txnId) {}

    void functionalRead(Addr txnId, Packet *pkt, WriteMask &mask) {}

    int functionalWrite(Addr txnId, Packet *pkt) {}

    ////////////////////////////////////////////////////////////////////////////
    // Commonly defined functions
    ////////////////////////////////////////////////////////////////////////////
    include "CHI-d2d-funcs.sm";

    ////////////////////////////////////////////////////////////////////////////
    // Outbound Ports
    ////////////////////////////////////////////////////////////////////////////
    out_port(network_reqOutPort, CHIRequestMsg,  reqOut);
    out_port(network_snpOutPort, CHIRequestMsg,  snpOut);
    out_port(network_rspOutPort, CHIResponseMsg, rspOut);
    out_port(network_datOutPort, CHIDataMsg,     datOut);
    out_port(reqRdyOutPort, CHIRequestMsg, reqRdy);
    out_port(snpRdyOutPort, CHIRequestMsg, snpRdy);
    out_port(bridge_reqOutPort, CHIRequestMsg,  d2dnode_reqOut);
    out_port(bridge_snpOutPort, CHIRequestMsg,  d2dnode_snpOut);
    out_port(bridge_rspOutPort, CHIResponseMsg, d2dnode_rspOut);
    out_port(bridge_datOutPort, CHIDataMsg,     d2dnode_datOut);
    out_port(triggerOutPort, TriggerMsg, triggerQueue);
    out_port(d2dCrdOutPort, D2DCrMsg, d2dnode_crdOut);
    out_port(retryTriggerOutPort, RetryTriggerMsg, retryTriggerQueue);

    ////////////////////////////////////////////////////////////////////////////
    // Used by this module
    ////////////////////////////////////////////////////////////////////////////
    
    TBE getTxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (TxReqMapTable.isPresent(addr)) {
            return TxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getTxSnpEntry(Addr addr), return_by_pointer="yes" {
        if (TxSnpMapTable.isPresent(addr)) {
            return TxSnpMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getInvalidTBE(Addr addr), return_by_pointer="yes" {
        // There is no valid Rx REMAP entries required
        return OOD;
    }

    TBE getActiveTBE(Addr addr), return_by_pointer="yes" {
        TBE snp_tbe_tx := getTxReqMapEntry(addr);
        TBE req_tbe_tx := getTxSnpEntry(addr);
        if (is_valid(snp_tbe_tx)) {
            return snp_tbe_tx;
        }
        if (is_valid(req_tbe_tx)) {
            return req_tbe_tx;
        }
        return OOD;
    }

    bool expCompAck(CHIRequestType type) {
        if ((type == CHIRequestType:ReadShared) ||
            (type == CHIRequestType:ReadOnce) || 
            (type == CHIRequestType:ReadUnique) ||
            (type == CHIRequestType:CleanUnique)) {
            return true;
        } else {
            return false;
        }
    }

    TBE allocateTxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storTxReqMapTable.decrementReserved();
        assert(storTxReqMapTable.areNSlotsAvailable(1));

        // Create a new txn_id from the src die
        Addr addr := in_msg.addr;

        // Allocate a TBE entry
        TxReqMapTable.allocate(addr);
        TBE tbe := TxReqMapTable[addr];

        // Save the original/incoming src_id and txn_id
        tbe.addr                     := addr;
        tbe.o_src_id                 := in_msg.requestor;
        tbe.o_fwd_src_id             := in_msg.fwdRequestor;
        tbe.storSlot                 := storTxReqMapTable.addEntryToNewSlot();
        tbe.expCompAck               := expCompAck(in_msg.type);
        tbe.wakeup_pending_req       := false;
        tbe.pendReqAllowRetryFromD2D := true;
        tbe.pendReqAccAddr           := in_msg.accAddr;
        tbe.pendReqAccSize           := in_msg.accSize;
        tbe.pendReqRetToSrc          := in_msg.retToSrc;
        tbe.pendReqType              := in_msg.type;
        tbe.is_req_tx                := true;
        tbe.is_snp_tx                := false;

        return tbe;
    }

    TBE allocateTxSnpEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storTxSnpMapTable.decrementReserved();
        assert(storTxSnpMapTable.areNSlotsAvailable(1));

        // Create a new txn_id from the src die
        Addr addr := in_msg.addr;

        // Allocate a TBE entry
        TxSnpMapTable.allocate(addr);
        TBE tbe := TxSnpMapTable[addr];

        // Save the original/incoming src_id and txn_id
        tbe.addr                     := addr;
        tbe.o_src_id                 := in_msg.requestor;
        tbe.o_fwd_src_id             := in_msg.fwdRequestor;
        tbe.storSlot                 := storTxSnpMapTable.addEntryToNewSlot();
        tbe.expCompAck               := expCompAck(in_msg.type);
        tbe.wakeup_pending_snp       := false;
        tbe.pendReqAllowRetryFromD2D := true;
        tbe.pendReqAccAddr           := in_msg.accAddr;
        tbe.pendReqAccSize           := in_msg.accSize;
        tbe.pendReqRetToSrc          := in_msg.retToSrc;
        tbe.pendReqType              := in_msg.type;
        tbe.is_req_tx                := false;
        tbe.is_snp_tx                := true;

        return tbe;
    }

    void processRetryQueue(Addr addr) {
      // send credit if requestor waiting for it and we have resources
      if (retryQueue.empty() == false) {
        RetryQueueEntry e := retryQueue.front_retry();
        bool has_avail := storTxReqMapTable.areNSlotsAvailable(1);
        if (has_avail) {
          storTxReqMapTable.incrementReserved();
          enqueue(retryTriggerOutPort, RetryTriggerMsg, 0) {
            out_msg.addr := e.addr;
            out_msg.retryDest := e.retryDest;
            out_msg.event := Event:SendPCrdGrant;
          }
          retryQueue.pop();
        }
      }
    }

    bool isSnpReqType(CHIRequestType type) {
        if ((type == CHIRequestType:SnpSharedFwd) ||
            (type == CHIRequestType:SnpNotSharedDirtyFwd) ||
            (type == CHIRequestType:SnpUniqueFwd) ||
            (type == CHIRequestType:SnpOnceFwd) ||
            (type == CHIRequestType:SnpOnce) ||
            (type == CHIRequestType:SnpShared) ||
            (type == CHIRequestType:SnpUnique) ||
            (type == CHIRequestType:SnpCleanInvalid) ||
            (type == CHIRequestType:SnpDvmOpSync_P1) ||
            (type == CHIRequestType:SnpDvmOpSync_P2) ||
            (type == CHIRequestType:SnpDvmOpNonSync_P1) ||
            (type == CHIRequestType:SnpDvmOpNonSync_P2)) {
          return true;
        } else {
          return false;
        }
    }

    void prepareRequestRetryToBridge(TBE tbe, CHIRequestMsg & out_msg) {
        assert(tbe.pendReqAllowRetryFromD2D);
        tbe.pendReqAllowRetryFromD2D := false;
        out_msg.allowRetry           := false;
        out_msg.addr                 := tbe.addr;
        out_msg.accAddr              := tbe.pendReqAccAddr;
        out_msg.accSize              := tbe.pendReqAccSize;
        out_msg.type                 := tbe.pendReqType;
        out_msg.retToSrc             := tbe.pendReqRetToSrc;
        bool is_snp_type             := isSnpReqType(out_msg.type);
        assert(is_snp_type == false);
    }

    void enqueueDoRetryToD2D(TBE tbe) {
        if (tbe.d2d_rcvd_retryack && tbe.d2d_rcvd_pcrdgrant) {
          enqueue(retryTriggerOutPort, RetryTriggerMsg, 0) {
            out_msg.addr  := tbe.addr;
            out_msg.event := Event:DoRetryToD2D;
          }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from NW)
    ////////////////////////////////////////////////////////////////////////////
    in_port(reqInPort, CHIRequestMsg, reqIn, rank=1) {
        if (reqInPort.isReady(clockEdge())) {
            peek(reqInPort, CHIRequestMsg) {
                if (in_msg.allowRetry) {
                    trigger(Event:AllocTxReqEntry, in_msg.addr, getActiveTBE(in_msg.addr));
                } else {
                    trigger(Event:AllocTxReqEntry_WithCredit, in_msg.addr, getActiveTBE(in_msg.addr));
                }
            }
        }
    }

    in_port(snpInPort, CHIRequestMsg, snpIn, rank=2) {
        if (snpInPort.isReady(clockEdge())) {
            peek(snpInPort, CHIRequestMsg) {
                trigger(Event:AllocTxSnpEntry, in_msg.addr, getTxSnpEntry(in_msg.addr));
            }
        }
    }

    in_port(reqRdyInPort, CHIRequestMsg, reqRdy, rank=3) {
        if (reqRdyInPort.isReady(clockEdge())) {
            peek(reqRdyInPort, CHIRequestMsg) {
                Event evt := Event:Frm_NW_Req;
                TBE tbe := getActiveTBE(in_msg.addr);
                trigger(evt, in_msg.addr, tbe);
            }
        }
    }

    in_port(snpRdyInPort, CHIRequestMsg, snpRdy, rank=4) {
        if (snpRdyInPort.isReady(clockEdge())) {
            peek(snpRdyInPort, CHIRequestMsg) {
                Event evt := Event:Frm_NW_Snp;
                TBE tbe := getTxSnpEntry(in_msg.addr);
                trigger(evt, in_msg.addr, tbe);
            }
        }
    }

    in_port(datInPort, CHIDataMsg, datIn, rank=4) {
        if (datInPort.isReady(clockEdge())) {
            peek(datInPort, CHIDataMsg) {
                // This must be in response of D2DNode generated request
                // which in turn must be generated in response to a
                // request recvd from the D2DBrdige.
                assert((in_msg.bitMask.count() <= data_channel_size) && (in_msg.bitMask.count() > 0));
                Event evt := frm_nw_dataToEvent(in_msg.type);
                if (evt == Event:Frm_NW_ReadData) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_WriteData) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    // assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_SnpData) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "Unsupported dat = %s\n",in_msg);
                    assert(false);
                }
            }
        }
    }

    in_port(rspInPort, CHIResponseMsg, rspIn, rank=5) {
        if (rspInPort.isReady(clockEdge())) {
            peek(rspInPort, CHIResponseMsg) {
                Event evt := frm_nw_rspToEvent(in_msg.type);
                if (evt == Event:Frm_NW_Comp) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_CompDBIDResp) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                }
                else if (evt == Event:Frm_NW_DBIDResp) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_CompAck) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_RetryAck) {
                    if (transmit_retry_from_nw) {
                        TBE tbe := getInvalidTBE(in_msg.addr);
                        trigger(evt, in_msg.addr, tbe);
                    } else {
                        error("Not implemented\n");
                    }
                } else if (evt == Event:Frm_NW_PCrdGrant) {
                    if (transmit_retry_from_nw) {
                        TBE tbe := getInvalidTBE(in_msg.addr);
                        trigger(evt, in_msg.addr, tbe);
                    } else {
                        error("Not implemented\n");
                    }
                } else if (evt == Event:Frm_NW_SnpResp) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "Unsupported msg = %s\n",in_msg);
                    assert(false);
                }
            }
        }
    }

    in_port(retryTriggerInPort, RetryTriggerMsg, retryTriggerQueue, rank=6) {
        if (retryTriggerInPort.isReady(clockEdge())) {
            peek(retryTriggerInPort, RetryTriggerMsg) {
                Event ev := in_msg.event;
                assert((ev == Event:SendRetryAck) || (ev == Event:SendPCrdGrant) || (ev == Event:DoRetryToD2D));
                TBE tbe := getActiveTBE(in_msg.addr);
                trigger(ev, in_msg.addr, tbe);
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from D2DBridge)
    ////////////////////////////////////////////////////////////////////////////
    in_port(bwReqInPort, CHIRequestMsg, d2dnode_reqIn, rank=20) {
        if (bwReqInPort.isReady(clockEdge())) {
            peek(bwReqInPort, CHIRequestMsg) {
                trigger(Event:Frm_d2d_Request, in_msg.addr, getInvalidTBE(in_msg.addr));
            }
        }
    }

    in_port(bwSnpInPort, CHIRequestMsg, d2dnode_snpIn, rank=21) {
        if (bwSnpInPort.isReady(clockEdge())) {
            peek(bwSnpInPort, CHIRequestMsg) {
                trigger(Event:Frm_d2d_Snp, in_msg.addr, getActiveTBE(in_msg.addr));
            }
        }
    }

    in_port(bwDatInPort, CHIDataMsg, d2dnode_datIn, rank=22) {
        if (bwDatInPort.isReady(clockEdge())) {
            peek(bwDatInPort, CHIDataMsg) {
                Event evt := frm_d2d_dataToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_ReadData) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_WriteData) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_SnpData) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    assert(is_valid(tbe));
                    assert(tbe.is_snp_tx);
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "Unsupported dat = %s\n");
                    assert(false);
                }
            }
        }
    }

    in_port(bwRspInPort, CHIResponseMsg, d2dnode_rspIn, rank=23) {
        if (bwRspInPort.isReady(clockEdge())) {
            peek(bwRspInPort, CHIResponseMsg) {
                Event evt := frm_d2d_rspToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_Comp) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_CompAck) {
                    TBE tbe := getInvalidTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if ((evt == Event:Frm_d2d_CompDBIDResp) ||
                           (evt == Event:Frm_d2d_DBIDResp)) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_RetryAck) {
                    if (transmit_retry_from_nw) {
                        TBE tbe := getActiveTBE(in_msg.addr);
                        assert(is_valid(tbe));
                        trigger(evt, in_msg.addr, tbe);
                    } else {
                        error("D2D Unsupported handling RetryAck");
                    }
                } else if (evt == Event:Frm_d2d_PCrdGrant) {
                    if (transmit_retry_from_nw) {
                        TBE tbe := getActiveTBE(in_msg.addr);
                        assert(is_valid(tbe));
                        trigger(evt, in_msg.addr, tbe);
                    } else {
                        error("D2D Unsupported handling PCrdGrant");
                    }
                } else if (evt == Event:Frm_d2d_SnpResp) {
                    TBE tbe := getActiveTBE(in_msg.addr);
                    assert(is_valid(tbe));
                    assert(tbe.is_snp_tx);
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "Unsupported msg = %s\n",in_msg);
                    assert(false);
                }
            }
        }
    }

    in_port(triggerInPort, Trigger, triggerQueue, rank=24) {
        if(triggerInPort.isReady(clockEdge())) {
            peek(triggerInPort, TriggerMsg) {
                trigger(in_msg.event, in_msg.addr, getActiveTBE(in_msg.addr));
            }
        }
    }

    void wakeupPendingReqs(TBE tbe) {
      if (tbe.wakeup_pending_req) {
        Addr addr := tbe.addr;
        wakeup_port(reqRdyInPort, addr);
        tbe.wakeup_pending_req := false;
      }
    }

    void wakeupPendingSnps(TBE tbe) {
        if (tbe.wakeup_pending_snp) {
            Addr addr := tbe.addr;
            wakeup_port(snpRdyInPort, addr);
            tbe.wakeup_pending_snp := false;
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Actions
    ////////////////////////////////////////////////////////////////////////////
    action(Alloc_TxSnpEntry, desc="") {
        check_allocate(storTxSnpMapTable);
        storTxSnpMapTable.incrementReserved();
        peek(snpInPort, CHIRequestMsg) {
            enqueue(snpRdyOutPort, CHIRequestMsg, allocation_latency) {
                assert(in_msg.addr == address);
                out_msg := in_msg;
            }
        }
        snpInPort.dequeue(clockEdge());
    }

    action(Alloc_TxReqEntry, desc="") {
        if (storTxReqMapTable.areNSlotsAvailable(1)) {
            storTxReqMapTable.incrementReserved();
            peek(reqInPort, CHIRequestMsg) {
                enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
                    out_msg := in_msg;
                }
            }
        } 
        else {
            peek(reqInPort, CHIRequestMsg) {
                assert(in_msg.allowRetry);
                enqueue(retryTriggerOutPort, RetryTriggerMsg, 0) {
                    out_msg.addr := in_msg.addr;
                    out_msg.event := Event:SendRetryAck;
                    out_msg.retryDest := in_msg.requestor;
                    retryQueue.emplace_retry(in_msg.addr,in_msg.requestor);
                }
            }
        }
        reqInPort.dequeue(clockEdge());
    }

    action(Alloc_TxReqEntry_WithCredit, desc="") {
        peek(reqInPort, CHIRequestMsg) {
            assert(in_msg.allowRetry == false);
            enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
                assert(in_msg.addr == address);
                out_msg := in_msg;
            }
        }
        reqInPort.dequeue(clockEdge());
    }

    action(StallRequest, desc="") {
        // was stalled because of an existing request
        assert(is_valid(tbe));
        assert(tbe.addr == address);
        // tracks pending
        tbe.wakeup_pending_req := true;
        stall_and_wait(reqRdyInPort, address);
    }

    action(StallSnoop, desc="") {
        assert(is_valid(tbe));
        assert(tbe.addr == address);
        tbe.wakeup_pending_snp := true;
        stall_and_wait(snpRdyInPort, address);
    }

    action(Fwd_ReqToNW, desc="") {
        peek(bwReqInPort, CHIRequestMsg) {
            enqueue(network_reqOutPort, CHIRequestMsg, lat_req_bridge_2_nw) {
                out_msg               := in_msg;
                out_msg.requestor     := machineID;
                out_msg.fwdRequestor  := machineID;
                out_msg.Destination.add(getHANodeIdOnDie(in_msg.addr));
            }
        }
        bwReqInPort.dequeue(clockEdge());
    }

    action(Fwd_SnpToNW, desc="") {
        peek(bwSnpInPort, CHIRequestMsg) {
            enqueue(network_snpOutPort, CHIRequestMsg, lat_snp_bridge_2_nw) {
                out_msg               := in_msg;
                out_msg.requestor     := machineID;
                out_msg.fwdRequestor  := machineID;
                out_msg.Destination.add(mapAddressToSnpDest(in_msg.addr));
            }
        }
        bwSnpInPort.dequeue(clockEdge());
    }

    action(Fwd_ReqToBridge, desc="") {
        peek(reqRdyInPort, CHIRequestMsg) {
            set_tbe(allocateTxRemapEntry(in_msg));
            enqueue(bridge_reqOutPort, CHIRequestMsg, lat_req_nw_2_bridge) {
                assert(is_valid(tbe));
                out_msg := in_msg;
                out_msg.allowRetry := true;
                out_msg.Destination.remove(machineID);
            }
        }
        reqRdyInPort.dequeue(clockEdge());
    }

    action(Fwd_SnpToBridge, desc="") {
        peek(snpRdyInPort, CHIRequestMsg) {
            set_tbe(allocateTxSnpEntry(in_msg));
            enqueue(bridge_snpOutPort, CHIRequestMsg, lat_snp_nw_2_bridge) {
                assert(is_valid(tbe));
                out_msg := in_msg;
                out_msg.allowRetry := false;
                out_msg.Destination.remove(machineID);
            }
        }
        snpRdyInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToBridge, desc="") {
        peek(datInPort, CHIDataMsg) {
            enqueue(bridge_datOutPort, CHIDataMsg, lat_dat_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        datInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToNW, desc="") { 
        assert(is_valid(tbe));
        peek(bwDatInPort, CHIDataMsg) {
            enqueue(network_datOutPort, CHIDataMsg, lat_dat_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        bwDatInPort.dequeue(clockEdge());
    }

    action(Receive_d2d_SnpDataResp, desc="") {
        assert(is_valid(tbe));
        peek(bwDatInPort, CHIDataMsg) {
            if ((tbe.dataBlkValid.isFull() == false) ||
                (in_msg.type == CHIDataType:SnpRespData_I_PD) ||
                (in_msg.type == CHIDataType:SnpRespData_SC_PD) ||
                (in_msg.type == CHIDataType:SnpRespData_SC_Fwded_SD_PD) ||
                (in_msg.type == CHIDataType:SnpRespData_SC_PD_Fwded_SC) ||
                (in_msg.type == CHIDataType:SnpRespData_I_Fwded_SD_PD) ||
                (in_msg.type == CHIDataType:SnpRespData_I_PD_Fwded_SC)) {
              // clear mask if started to receive new data
              if(tbe.dataBlkValid.isFull()){
                tbe.dataBlkValid.clear();
              }
              assert(tbe.dataBlkValid.isOverlap(in_msg.bitMask) == false);
              tbe.dataBlkValid.orMask(in_msg.bitMask);
            }
        }
    }

    action(Receive_d2d_CompDataResp, desc="") {
        assert(is_valid(tbe));
        peek(bwDatInPort, CHIDataMsg) {
            if ((tbe.dataBlkValid.isFull() == false) ||
                (in_msg.type == CHIDataType:CompData_UD_PD) ||
                (in_msg.type == CHIDataType:CompData_SD_PD) ||
                (in_msg.type == CHIDataType:CBWrData_UD_PD) ||
                (in_msg.type == CHIDataType:CBWrData_SD_PD) ||
                (in_msg.type == CHIDataType:NCBWrData)) {
                // clear mask if started to receive new data
                if(tbe.dataBlkValid.isFull()){
                  tbe.dataBlkValid.clear();
                }  
                assert(tbe.dataBlkValid.isOverlap(in_msg.bitMask) == false);
                tbe.dataBlkValid.orMask(in_msg.bitMask);
            }
        }
    }

    action(UpdateDataState_FrmCompRespData, desc="") {
        bool release_req_entry := false;
        if (tbe.dataBlkValid.isFull()) {
            release_req_entry := (tbe.expCompAck == false);
        }
        if (release_req_entry) {
            enqueue(triggerOutPort, TriggerMsg, 0) {
                out_msg.addr  := tbe.addr;
                out_msg.event := Event:DeAllocTxReqEntry;
            }
        }
    }

    action(UpdateDataState_FrmSnpRespData, desc="") {
        bool release_snp_entry := false;
        if (tbe.dataBlkValid.isFull()) {
            release_snp_entry := true;
        }
        if (release_snp_entry) {
            enqueue(triggerOutPort, TriggerMsg, 0) {
                out_msg.addr  := tbe.addr;
                out_msg.event := Event:DeAllocTxSnpEntry;
            }
        }
    }

    action(Fwd_DataToNW_ToHA, desc="") {
        peek(bwDatInPort, CHIDataMsg) {
            enqueue(network_datOutPort, CHIDataMsg, lat_dat_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(getHANodeIdOnDie(in_msg.addr));
            }
        }
        bwDatInPort.dequeue(clockEdge());
    }

    action(Fwd_CompAckToBridge, desc="") {
        assert(is_valid(tbe));
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        enqueue(triggerOutPort, TriggerMsg, 0) {
            assert(tbe.expCompAck);
            out_msg.addr     := tbe.addr;
            out_msg.event    := Event:DeAllocTxReqEntry;
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Fwd_DBIDToBridge, desc="") {
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Fwd_GenericRspToNW, desc="") {
        assert(is_valid(tbe));
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        if (tbe.expCompAck == false) {
            // Txn conclusion
            Event evt := Event:DeAllocTxReqEntry;
            if (tbe.is_snp_tx) {
                evt := Event:DeAllocTxSnpEntry;
            }
            enqueue(triggerOutPort, TriggerMsg, 0) {
                out_msg.addr     := tbe.addr;
                out_msg.event    := evt;
            }
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Fwd_CompAckToNW, desc="") {
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(getHANodeIdOnDie(in_msg.addr));
            }
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Fwd_DBIDToNW, desc="") {
        assert(is_valid(tbe));
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Fwd_CompDBIDToNW, desc="") {
        assert(is_valid(tbe));
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        // Txn conclusion
        enqueue(triggerOutPort, TriggerMsg, 0) {
            out_msg.addr     := tbe.addr;
            out_msg.event    := Event:DeAllocTxReqEntry;
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Process_D2DRetry, desc="") {
        assert(transmit_retry_from_nw);
        assert(is_valid(tbe));
        assert(tbe.pendReqAllowRetryFromD2D);
        assert(tbe.d2d_rcvd_retryack == false);
        tbe.d2d_rcvd_retryack := true;
        bwRspInPort.dequeue(clockEdge());
        enqueueDoRetryToD2D(tbe);
    }

    action(Process_D2DPcrdGrant, desc="") {
        assert(transmit_retry_from_nw);
        assert(is_valid(tbe));
        assert(tbe.pendReqAllowRetryFromD2D);
        tbe.d2d_rcvd_pcrdgrant := true;
        bwRspInPort.dequeue(clockEdge());
        enqueueDoRetryToD2D(tbe);
    }

    action(Send_D2DCredit, desc="Send credits to the D2DBridge") {
        enqueue(d2dCrdOutPort, D2DCrMsg, lat_crd_transfer) {
            out_msg.cr_inc := true;
        }
    }

    action(De_AllocRequest, desc="Deallocate Tx REQ Remap entries") {
        assert(is_valid(tbe));
        assert(tbe.is_req_tx);
        wakeupPendingReqs(tbe);
        storTxReqMapTable.removeEntryFromSlot(tbe.storSlot);
        TxReqMapTable.deallocate(address);
        processRetryQueue(address);
    }

    action(De_AllocSnpRequest, desc="Deallocate Tx SNP Remap entries") {
        assert(is_valid(tbe));
        assert(tbe.is_snp_tx);
        wakeupPendingSnps(tbe);
        storTxSnpMapTable.removeEntryFromSlot(tbe.storSlot);
        TxSnpMapTable.deallocate(address);
    }

    action(popTriggerQueue, desc="Pop trigger queue.") {
        triggerInPort.dequeue(clockEdge());
    }

    action(Fwd_GenericRspToBridge, desc="Fwd rsp to D2D Bridge") {
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Send_RetryAck, desc="Send RetryAck to reqtor") {
        peek(retryTriggerInPort, RetryTriggerMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, response_latency) {
                out_msg.addr := in_msg.addr;
                out_msg.type := CHIResponseType:RetryAck;
                out_msg.responder := machineID;
                out_msg.Destination.add(in_msg.retryDest);
            }
        }
    }

    action(Send_PCrdGrant, desc="") {
      peek(retryTriggerInPort, RetryTriggerMsg) {
        enqueue(network_rspOutPort, CHIResponseMsg, response_latency) {
          out_msg.addr := in_msg.addr;
          out_msg.type := CHIResponseType:PCrdGrant;
          out_msg.responder := machineID;
          out_msg.Destination.add(in_msg.retryDest);
        }
      }
    }

    action(Pop_RetryTriggerQueue, desc="Pop Retry") {
        retryTriggerInPort.dequeue(clockEdge());
    }

    action(Fwd_RetryRspToBridge_Transmit, desc="Fwd ") {
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Fwd_RetryReqToD2D, desc="") {
        enqueue(bridge_reqOutPort, CHIRequestMsg, lat_req_nw_2_bridge) {
            prepareRequestRetryToBridge(tbe, out_msg);
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Transitions
    ////////////////////////////////////////////////////////////////////////////
    transition(stable, AllocTxReqEntry) {
        Alloc_TxReqEntry;
    }

    transition(stable, AllocTxReqEntry_WithCredit) {
        Alloc_TxReqEntry_WithCredit;
    }

    transition(stable, Frm_d2d_Request, busy_intr) {
        Fwd_ReqToNW;
        Send_D2DCredit;
    }

    transition({busy_blkd, busy_intr, stable}, Frm_d2d_ReadData) {
        Receive_d2d_CompDataResp;
        UpdateDataState_FrmCompRespData;
        Fwd_DataToNW;
        Send_D2DCredit;
    }

    transition(busy_blkd, Frm_d2d_SnpData) {
        Receive_d2d_SnpDataResp;
        UpdateDataState_FrmSnpRespData;
        Fwd_DataToNW;
        Send_D2DCredit;
    }

    transition(stable, Frm_d2d_WriteData) {
        Fwd_DataToNW_ToHA;
        Send_D2DCredit;
    }

    transition(busy_intr, Frm_d2d_Comp) {
        Fwd_GenericRspToNW;
        Send_D2DCredit;
    }

    transition(busy_blkd, Frm_d2d_SnpResp) {
        Fwd_GenericRspToNW;
        Send_D2DCredit;
    }

    transition(stable, Frm_d2d_CompAck) {
        Fwd_CompAckToNW;
        Send_D2DCredit;
    }

    transition(busy_intr, Frm_d2d_CompDBIDResp) {
        Fwd_CompDBIDToNW;
        Send_D2DCredit;
    }

    transition(busy_intr, Frm_d2d_DBIDResp) {
        Fwd_DBIDToNW;
        Send_D2DCredit;
    }

    transition(busy_intr, Frm_d2d_RetryAck) {
        Process_D2DRetry;
        Send_D2DCredit;
    }

    transition(busy_intr, Frm_d2d_PCrdGrant) {
        Process_D2DPcrdGrant;
        Send_D2DCredit;
    }

    transition(busy_intr, DoRetryToD2D) {
        Fwd_RetryReqToD2D;
        Pop_RetryTriggerQueue;
    }

    transition(stable, {Frm_NW_ReadData, Frm_NW_SnpData}) {
        Fwd_DataToBridge;
    }

    transition({stable, busy_intr}, Frm_NW_WriteData) {
        Fwd_DataToBridge;
    }

    transition(stable, Frm_NW_Req, busy_intr) {
        Fwd_ReqToBridge;
    }

    transition({busy_blkd, busy_intr}, Frm_NW_Req) {
        StallRequest;
    }
   
    transition(stable, {Frm_NW_SnpResp, Frm_NW_Comp}) {
        Fwd_GenericRspToBridge;
    }

    transition({busy_blkd, busy_intr}, Frm_NW_CompAck) {
        Fwd_CompAckToBridge;
    }

    transition({stable, busy_intr}, Frm_NW_RetryAck) {
        Fwd_RetryRspToBridge_Transmit;
    }

    transition({stable, busy_intr}, Frm_NW_PCrdGrant) {
        Fwd_RetryRspToBridge_Transmit;
    }

    transition(busy_intr, DeAllocTxReqEntry, stable) {
        De_AllocRequest;
        popTriggerQueue;
    }

    transition(busy_blkd, DeAllocTxSnpEntry, stable) {
        De_AllocSnpRequest;
        popTriggerQueue;
    }

    transition({busy_intr,stable}, SendRetryAck) {
        Send_RetryAck;
        Pop_RetryTriggerQueue;
    }

    transition({busy_intr,stable}, SendPCrdGrant) {
        Send_PCrdGrant;
        Pop_RetryTriggerQueue;
    }

    transition(stable, Frm_NW_CompDBIDResp) {
        Fwd_DBIDToBridge;
    }

    transition(stable, Frm_NW_DBIDResp) {
        Fwd_DBIDToBridge;
    }

    transition({busy_intr, stable}, AllocTxSnpEntry) {
        Alloc_TxSnpEntry;
    }

    transition({busy_intr, stable}, Frm_NW_Snp, busy_blkd) {
        Fwd_SnpToBridge;
    }

    transition(busy_blkd, Frm_NW_Snp) {
        StallSnoop;
    }

    transition(stable, Frm_d2d_Snp) {
        Fwd_SnpToNW;
        Send_D2DCredit;
    }

}