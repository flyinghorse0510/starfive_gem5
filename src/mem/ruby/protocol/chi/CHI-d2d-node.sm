/*
 * Copyright (c) 2022 Starfive
 * All rights reserved
 */

machine(MachineType:D2DNode, "CHI interface to the D2D bridge") :

    // CHI network side channels
    MessageBuffer * reqIn,   network="From", virtual_network="0", vnet_type="none";
    MessageBuffer * snpIn,   network="From", virtual_network="1", vnet_type="none";
    MessageBuffer * rspIn,   network="From", virtual_network="2", vnet_type="none";
    MessageBuffer * datIn,   network="From", virtual_network="3", vnet_type="response";

    MessageBuffer * reqOut,   network="To", virtual_network="0", vnet_type="none";
    MessageBuffer * snpOut,   network="To", virtual_network="1", vnet_type="none";
    MessageBuffer * rspOut,   network="To", virtual_network="2", vnet_type="none";
    MessageBuffer * datOut,   network="To", virtual_network="3", vnet_type="response";

    // CHI bridge side channels
    MessageBuffer * d2dnode_reqIn;
    MessageBuffer * d2dnode_snpIn;
    MessageBuffer * d2dnode_rspIn;
    MessageBuffer * d2dnode_datIn;

    MessageBuffer * d2dnode_reqOut;
    MessageBuffer * d2dnode_snpOut;
    MessageBuffer * d2dnode_rspOut;
    MessageBuffer * d2dnode_datOut;

    // Send credits (for back pressure) for d2d node
    MessageBuffer * d2dnode_crdOut;

    // Accepted requests
    MessageBuffer * reqRdy;

    // Remap table allocation latency
    int allocation_latency  := 1;

    // Bridge --> NW latencies
    int lat_req_bridge_2_nw := 1;
    int lat_rsp_bridge_2_nw := 1;
    int lat_snp_bridge_2_nw := 1;
    int lat_dat_bridge_2_nw := 1;

    // NW --> Bridge NW latencies
    int lat_req_nw_2_bridge := 1;
    int lat_rsp_nw_2_bridge := 1;
    int lat_snp_nw_2_bridge := 1;
    int lat_dat_nw_2_bridge := 1;

    // Number of REMAP entries
    int num_txremap_entries := 8;
    int num_rxremap_entries := 8;

    int data_channel_size;

    // Src and Dst die Ids
    int src_die_id := 0;
    int dst_die_id := 1;
    
{
    // Cache block size
    int blockSize, default="RubySystem::getBlockSizeBytes()";

    state_declaration(State, default="D2DNode_State_null") {
        // Null state for debugging
        null,         AccessPermission:Invalid,     desc="Null state";
        busy,         AccessPermission:Invalid,     desc="A tracker entry has been allocated, so the transaction is progress";
        stable,       AccessPermission:Invalid,     desc="Stable but invalid, no ongoing transactions";
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Events
    ////////////////////////////////////////////////////////////////////////////
    enumeration(Event) {
        AllocTxReqEntry,   desc="Allocate a Tx Remap entry";
        AllocRxReqEntry,   desc="Allocate a Rx Remap entry";
        FwdReqMsg,         desc="Fwd to D2DBridge";
        null,              desc="";
        Final,             desc="Finalize event";
    }

    ////////////////////////////////////////////////////////////////////////////
    // Structure
    ////////////////////////////////////////////////////////////////////////////

    structure(TriggerQueue, external ="yes") {
        Event front();
        Event back();
        bool frontNB();
        bool backNB();
        bool empty();
        void push(Event);
        void pushNB(Event);
        void pushFront(Event);
        void pushFrontNB(Event);
        void pop();
        void clear();
    }

    structure(TBE, desc="Common structure for Tx and Rx Table Entry") {
        State state,              desc="Once allocated, the state must be always busy";
        Addr addr,                desc="Address corresponding to this request";
        /* Generated by the originating requestor */
        MachineID o_src_id,       desc="d2d Src Id, Requestor HNF";
        MachineID o_fwd_src_id,   desc="d2d fwd Src Id, Fwd Requestor";
        Addr o_d2d_txn_id,        desc="d2d Txn Id, Original";

        // Unused fields to appease the SLICC compiler
        TriggerQueue actions,     template="<D2DNode_Event>", desc="List of actions";
        Event slicchack1,         desc="fix compiler not including headers";
    }

    structure(TBETable, external ="yes") {
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
    }

    structure(TBEStorage, external ="yes") {
        int size();
        int capacity();
        int reserved();
        int addEntryToNewSlot();
        bool areNSlotsAvailable(int n);
        void incrementReserved();
        void decrementReserved();
    }

    TBETable TxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_txremap_entries";
    TBEStorage storTxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_txremap_entries";
    
    TBETable RxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_rxremap_entries";
    TBEStorage storRxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_rxremap_entries";

    ////////////////////////////////////////////////////////////////////////////
    // Interface functions required by SLICC
    ////////////////////////////////////////////////////////////////////////////
    State getState(TBE tbe, Addr addr) {
        if (is_valid(tbe)) {
            assert(tbe.state == State:busy);
            return tbe.state;
        } else {
            return State:stable;
        }
    }

    void setState(TBE tbe, Addr addr, State state) {
        if (is_valid(tbe)) {
            tbe.state := state;
        }
    }
    
    void setAccessPermission(Addr txnId, State state) {}

    AccessPermission getAccessPermission(Addr txnId) {}

    void functionalRead(Addr txnId, Packet *pkt, WriteMask &mask) {}

    int functionalWrite(Addr txnId, Packet *pkt) {}

    ////////////////////////////////////////////////////////////////////////////
    // Commonly defined functions
    ////////////////////////////////////////////////////////////////////////////
    include "CHI-d2d-funcs.sm";

    ////////////////////////////////////////////////////////////////////////////
    // Used by this module
    ////////////////////////////////////////////////////////////////////////////
    
    TBE getTxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (TxReqMapTable.isPresent(addr)) {
            return TxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getRxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (RxReqMapTable.isPresent(addr)) {
            return RxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE allocateRxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storRxReqMapTable.decrementReserved();
        assert(storRxReqMapTable.areNSlotsAvailable(1));

        Addr addr          := in_msg.addr;
        int tbeStorSlot    := storRxReqMapTable.addEntryToNewSlot();
        
        RxReqMapTable.allocate(addr);
        TBE tbe           := RxReqMapTable[addr];

        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.o_d2d_txn_id  := in_msg.d2d_txn_id;
        
        return tbe;
    }

    TBE allocateTxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storTxReqMapTable.decrementReserved();
        assert(storTxReqMapTable.areNSlotsAvailable(1));

        // Create a new txn_id from the src die
        Addr addr := in_msg.addr;

        // Allocate a TBE entry
        TxReqMapTable.allocate(addr);
        TBE tbe := TxReqMapTable[addr];

        // Save the original/incoming src_id and txn_id
        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.o_d2d_txn_id  := in_msg.d2d_txn_id;

        return tbe;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Outbound Ports
    ////////////////////////////////////////////////////////////////////////////
    out_port(network_reqOutPort, CHIRequestMsg,  reqOut);
    out_port(network_snpOutPort, CHIRequestMsg,  snpOut);
    out_port(network_rspOutPort, CHIResponseMsg, rspOut);
    out_port(network_datOutPort, CHIDataMsg,     datOut);

    out_port(reqRdyOutPort, CHIRequestMsg, reqRdy);

    out_port(bridge_reqOutPort, CHIRequestMsg,  d2dnode_reqOut);
    out_port(bridge_snpOutPort, CHIRequestMsg,  d2dnode_snpOut);
    out_port(bridge_rspOutPort, CHIResponseMsg, d2dnode_rspOut);
    out_port(bridge_datOutPort, CHIDataMsg,     d2dnode_datOut);

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from NW)
    ////////////////////////////////////////////////////////////////////////////
    in_port(reqInPort, CHIRequestMsg, reqIn, rank=1) {
        if (reqInPort.isReady(clockEdge())) {
            peek(reqInPort, CHIRequestMsg) {
                trigger(Event:AllocTxReqEntry, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(reqRdyInPort, CHIRequestMsg, reqRdy, rank=2) {
        if (reqRdyInPort.isReady(clockEdge())) {
            peek(reqRdyInPort, CHIRequestMsg) {
                trigger(Event:FwdReqMsg, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    // Inbound Ports (from Bridge)
    in_port(bwReqInPort, CHIRequestMsg, d2dnode_reqIn, rank=3) {
        if (bwReqInPort.isReady(clockEdge())) {
            peek(bwReqInPort, CHIRequestMsg) {
                // TODO: Think carefully how are you going to access the RxRemap Table
                trigger(Event:AllocRxReqEntry, in_msg.addr, getRxReqMapEntry(in_msg.addr));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Actions
    ////////////////////////////////////////////////////////////////////////////
    action(Alloc_TxReqEntry, desc="") {
        if (storTxReqMapTable.areNSlotsAvailable(1)) {
            storTxReqMapTable.incrementReserved();
            peek(reqInPort, CHIRequestMsg) {
                set_tbe(allocateTxRemapEntry(in_msg));
                enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
                    out_msg := in_msg;
                }
            }
        } 
        else {
            DPRINTF(RubyCHIDebugStr5, "Retry not implement");
            assert(false);
        }
        reqInPort.dequeue(clockEdge());
    }

    action(Alloc_RxReqEntry, desc="") {
        /**
         * We do not have to send retries
         * for the REQs received from the
         * bridge side, so create a resource
         * stall
         */
        check_allocate(storRxReqMapTable);
        storRxReqMapTable.incrementReserved();
        peek(bwReqInPort, CHIRequestMsg) {
            set_tbe(allocateRxRemapEntry(in_msg));
            enqueue(network_reqOutPort, CHIRequestMsg, lat_req_bridge_2_nw) {
                DPRINTF(RubyD2DStr5,"in_msg=%s\n",in_msg);
                out_msg               := in_msg;
                out_msg.requestor     := machineID;
                out_msg.fwdRequestor  := machineID;
                out_msg.Destination.add(getHANodeIdOnDie(tbe.addr));
                DPRINTF(RubyD2DStr5,"out_msg=%s\n",out_msg);

            }
        }
        bwReqInPort.dequeue(clockEdge());
    }

    action(Fwd_ReqMsg_ToBridge, desc="") {
        peek(reqRdyInPort, CHIRequestMsg) {
            enqueue(bridge_reqOutPort, CHIRequestMsg, lat_req_nw_2_bridge) {
                assert(is_valid(tbe));
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
                DPRINTF(RubyD2DStr5,"out_msg=%s\n",out_msg);
            }
        }
        reqRdyInPort.dequeue(clockEdge());
    }

    ////////////////////////////////////////////////////////////////////////////
    // Transitions
    ////////////////////////////////////////////////////////////////////////////
    transition(stable, AllocTxReqEntry, busy) {
        Alloc_TxReqEntry;
    }

    transition(stable, AllocRxReqEntry, busy) {
        Alloc_RxReqEntry;
    }

    transition(busy, FwdReqMsg) {
        Fwd_ReqMsg_ToBridge;
    }
}