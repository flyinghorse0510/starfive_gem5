/*
 * Copyright (c) 2022 Starfive
 * All rights reserved
 */

machine(MachineType:D2DNode, "CHI interface to the D2D bridge") :

    // CHI network side channels
    MessageBuffer * reqIn,   network="From", virtual_network="0", vnet_type="none";
    MessageBuffer * snpIn,   network="From", virtual_network="1", vnet_type="none";
    MessageBuffer * rspIn,   network="From", virtual_network="2", vnet_type="none";
    MessageBuffer * datIn,   network="From", virtual_network="3", vnet_type="response";

    MessageBuffer * reqOut,   network="To", virtual_network="0", vnet_type="none";
    MessageBuffer * snpOut,   network="To", virtual_network="1", vnet_type="none";
    MessageBuffer * rspOut,   network="To", virtual_network="2", vnet_type="none";
    MessageBuffer * datOut,   network="To", virtual_network="3", vnet_type="response";

    // CHI bridge side channels
    MessageBuffer * d2dnode_reqIn;
    MessageBuffer * d2dnode_snpIn;
    MessageBuffer * d2dnode_rspIn;
    MessageBuffer * d2dnode_datIn;

    MessageBuffer * d2dnode_reqOut;
    MessageBuffer * d2dnode_snpOut;
    MessageBuffer * d2dnode_rspOut;
    MessageBuffer * d2dnode_datOut;

    // Send credits (for back pressure) for d2d node
    MessageBuffer * d2dnode_crdOut;

    // Accepted requests
    MessageBuffer * reqRdy;

    // Remap table allocation latency
    int allocation_latency  := 1;

    // Bridge --> NW latencies
    int lat_req_bridge_2_nw := 1;
    int lat_rsp_bridge_2_nw := 1;
    int lat_snp_bridge_2_nw := 1;
    int lat_dat_bridge_2_nw := 1;

    // NW --> Bridge NW latencies
    int lat_req_nw_2_bridge := 1;
    int lat_rsp_nw_2_bridge := 1;
    int lat_snp_nw_2_bridge := 1;
    int lat_dat_nw_2_bridge := 1;

    // Number of REMAP entries
    int num_txremap_entries := 8;
    int num_rxremap_entries := 8;

    int data_channel_size;

    // Src and Dst die Ids
    int src_die_id := 0;
    int dst_die_id := 1;
    
{
    // Cache block size
    int blockSize, default="RubySystem::getBlockSizeBytes()";

    state_declaration(State, default="D2DNode_State_null") {
        // Null state for debugging
        null,         AccessPermission:Invalid,     desc="Null state";
        busy,         AccessPermission:Invalid,     desc="A tracker entry has been allocated, so the transaction is progress";
        stable,       AccessPermission:Invalid,     desc="Stable but invalid, no ongoing transactions";
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Events
    ////////////////////////////////////////////////////////////////////////////
    enumeration(Event) {
        AllocTxReqEntry,     desc="Allocate a Tx Remap entry";
        AllocRxReqEntry,     desc="Allocate a Rx Remap entry";

        Frm_NW_ReadData,     desc="Dat Rsp to a Read Data from NW";
        Frm_NW_WriteData,    desc="Dat Rsp to a Write Data from NW";
        Frm_NW_SnpData,      desc="Dat Rsp to a Snp Data from NW";

        Frm_d2d_ReadData,    desc="Dat Rsp to a Read Data from d2d";
        Frm_d2d_WriteData,   desc="Dat Rsp to a Write Data from d2d";
        Frm_d2d_SnpData,     desc="Dat Rsp to a Snp Data from d2d";

        Frm_NW_Comp,         desc="Comp Rsp from NW side";
        Frm_NW_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_NW_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_NW_CompAck,      desc="CompAck Rsp from NW side";
        Frm_NW_SnpResp,      desc="SnpRsp from NW side";
        Frm_NW_RetryAck,     desc="RetryAck from NW side";
        Frm_NW_PCrdGrant,    desc="PCrdGrant from NW side";

        Frm_d2d_Comp,         desc="Comp Rsp from NW side";
        Frm_d2d_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_d2d_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_d2d_CompAck,      desc="CompAck Rsp from NW side";
        Frm_d2d_SnpResp,      desc="SnpRsp from NW side";
        Frm_d2d_RetryAck,     desc="RetryAck from NW side";
        Frm_d2d_PCrdGrant,    desc="PCrdGrant from NW side";

        FwdReqMsg,         desc="Fwd to D2DBridge";
        null,              desc="";
        Final,             desc="Finalize event";
    }

    ////////////////////////////////////////////////////////////////////////////
    // Structure
    ////////////////////////////////////////////////////////////////////////////

    structure(TriggerQueue, external ="yes") {
        Event front();
        Event back();
        bool frontNB();
        bool backNB();
        bool empty();
        void push(Event);
        void pushNB(Event);
        void pushFront(Event);
        void pushFrontNB(Event);
        void pop();
        void clear();
    }

    structure(TBE, desc="Common structure for Tx and Rx Table Entry") {
        State state,              desc="Once allocated, the state must be always busy";
        Addr addr,                desc="Address corresponding to this request";
        /* Generated by the originating requestor */
        MachineID o_src_id,       desc="d2d Src Id, Requestor HNF";
        MachineID o_fwd_src_id,   desc="d2d fwd Src Id, Fwd Requestor";
        Addr o_d2d_txn_id,        desc="d2d Txn Id, Original";
        MachineID haId,           desc="HA Id, that serves as the destion for requests and CompAcks";

        // Unused fields to appease the SLICC compiler
        TriggerQueue actions,     template="<D2DNode_Event>", desc="List of actions";
        Event slicchack1,         desc="fix compiler not including headers";
    }

    structure(TBETable, external ="yes") {
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
    }

    structure(TBEStorage, external ="yes") {
        int size();
        int capacity();
        int reserved();
        int addEntryToNewSlot();
        bool areNSlotsAvailable(int n);
        void incrementReserved();
        void decrementReserved();
    }

    TBETable TxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_txremap_entries";
    TBEStorage storTxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_txremap_entries";
    
    TBETable RxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_rxremap_entries";
    TBEStorage storRxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_rxremap_entries";

    ////////////////////////////////////////////////////////////////////////////
    // Interface functions required by SLICC
    ////////////////////////////////////////////////////////////////////////////
    State getState(TBE tbe, Addr addr) {
        if (is_valid(tbe)) {
            assert(tbe.state == State:busy);
            return tbe.state;
        } else {
            return State:stable;
        }
    }

    void setState(TBE tbe, Addr addr, State state) {
        if (is_valid(tbe)) {
            tbe.state := state;
        }
    }
    
    void setAccessPermission(Addr txnId, State state) {}

    AccessPermission getAccessPermission(Addr txnId) {}

    void functionalRead(Addr txnId, Packet *pkt, WriteMask &mask) {}

    int functionalWrite(Addr txnId, Packet *pkt) {}

    ////////////////////////////////////////////////////////////////////////////
    // Commonly defined functions
    ////////////////////////////////////////////////////////////////////////////
    include "CHI-d2d-funcs.sm";

    ////////////////////////////////////////////////////////////////////////////
    // Used by this module
    ////////////////////////////////////////////////////////////////////////////
    
    TBE getTxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (TxReqMapTable.isPresent(addr)) {
            return TxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getRxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (RxReqMapTable.isPresent(addr)) {
            return RxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE allocateRxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storRxReqMapTable.decrementReserved();
        assert(storRxReqMapTable.areNSlotsAvailable(1));

        Addr addr          := in_msg.addr;
        int tbeStorSlot    := storRxReqMapTable.addEntryToNewSlot();
        
        RxReqMapTable.allocate(addr);
        TBE tbe           := RxReqMapTable[addr];

        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.o_d2d_txn_id  := in_msg.d2d_txn_id;
        tbe.haId          := getHANodeIdOnDie(addr);

        return tbe;
    }

    TBE allocateTxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storTxReqMapTable.decrementReserved();
        assert(storTxReqMapTable.areNSlotsAvailable(1));

        // Create a new txn_id from the src die
        Addr addr := in_msg.addr;

        // Allocate a TBE entry
        TxReqMapTable.allocate(addr);
        TBE tbe := TxReqMapTable[addr];

        // Save the original/incoming src_id and txn_id
        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.o_d2d_txn_id  := in_msg.d2d_txn_id;

        return tbe;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Outbound Ports
    ////////////////////////////////////////////////////////////////////////////
    out_port(network_reqOutPort, CHIRequestMsg,  reqOut);
    out_port(network_snpOutPort, CHIRequestMsg,  snpOut);
    out_port(network_rspOutPort, CHIResponseMsg, rspOut);
    out_port(network_datOutPort, CHIDataMsg,     datOut);

    out_port(reqRdyOutPort, CHIRequestMsg, reqRdy);

    out_port(bridge_reqOutPort, CHIRequestMsg,  d2dnode_reqOut);
    out_port(bridge_snpOutPort, CHIRequestMsg,  d2dnode_snpOut);
    out_port(bridge_rspOutPort, CHIResponseMsg, d2dnode_rspOut);
    out_port(bridge_datOutPort, CHIDataMsg,     d2dnode_datOut);

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from NW)
    ////////////////////////////////////////////////////////////////////////////
    in_port(reqInPort, CHIRequestMsg, reqIn, rank=1) {
        if (reqInPort.isReady(clockEdge())) {
            peek(reqInPort, CHIRequestMsg) {
                trigger(Event:AllocTxReqEntry, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(reqRdyInPort, CHIRequestMsg, reqRdy, rank=2) {
        if (reqRdyInPort.isReady(clockEdge())) {
            peek(reqRdyInPort, CHIRequestMsg) {
                trigger(Event:FwdReqMsg, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(datInPort, CHIDataMsg, datIn, rank=3) {
        if (datInPort.isReady(clockEdge())) {
            peek(datInPort, CHIDataMsg) {
                // This must be in response of D2DNode generated request
                // which in turn must be generated in response to a
                // request recvd from the D2DBrdige.
                assert((in_msg.bitMask.count() <= data_channel_size) && (in_msg.bitMask.count() > 0));
                Event evt := frm_nw_dataToEvent(in_msg.type);
                if (evt == Event:Frm_NW_ReadData) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_WriteData) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_SnpData) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                }
            }
        }
    }

    in_port(rspInPort, CHIResponseMsg, rspIn, rank=4) {
        if (rspInPort.isReady(clockEdge())) {
            peek(rspInPort, CHIResponseMsg) {
                Event evt := frm_nw_rspToEvent(in_msg.type);
                if (evt == Event:Frm_NW_Comp) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_CompAck) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_SnpResp) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                } else if ((evt == Event:Frm_NW_RetryAck) ||
                           (evt == Event:Frm_NW_PCrdGrant)) {
                    DPRINTF(RubyCHIDebugStr5, "RetryAck and PCRdGrant to do\n");
                    assert(false);
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from D2DBridge)
    ////////////////////////////////////////////////////////////////////////////
    in_port(bwReqInPort, CHIRequestMsg, d2dnode_reqIn, rank=20) {
        if (bwReqInPort.isReady(clockEdge())) {
            peek(bwReqInPort, CHIRequestMsg) {
                // TODO: Think carefully how are you going to access the RxRemap Table
                trigger(Event:AllocRxReqEntry, in_msg.addr, getRxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(bwDatInPort, CHIDataMsg, d2dnode_datIn, rank=21) {
        if (bwDatInPort.isReady(clockEdge())) {
            peek(bwDatInPort, CHIDataMsg) {
                Event evt := frm_d2d_dataToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_ReadData) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_WriteData) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_SnpData) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                }
            }
        }
    }

    in_port(bwRspInPort, CHIResponseMsg, d2dnode_rspIn, rank=22) {
        if (bwRspInPort.isReady(clockEdge())) {
            peek(bwRspInPort, CHIResponseMsg) {
                Event evt := frm_d2d_rspToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_Comp) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_CompAck) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "D2D Rsp type TODO = %s\n",in_msg);
                    assert(false);
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Actions
    ////////////////////////////////////////////////////////////////////////////
    action(Alloc_TxReqEntry, desc="") {
        if (storTxReqMapTable.areNSlotsAvailable(1)) {
            storTxReqMapTable.incrementReserved();
            peek(reqInPort, CHIRequestMsg) {
                set_tbe(allocateTxRemapEntry(in_msg));
                enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
                    out_msg := in_msg;
                }
            }
        } 
        else {
            DPRINTF(RubyCHIDebugStr5, "Retry not implement");
            assert(false);
        }
        reqInPort.dequeue(clockEdge());
    }

    action(Alloc_RxReqEntry, desc="") {
        /**
         * We do not have to send retries
         * for the REQs received from the
         * bridge side, so create a resource
         * stall
         */
        check_allocate(storRxReqMapTable);
        storRxReqMapTable.incrementReserved();
        peek(bwReqInPort, CHIRequestMsg) {
            set_tbe(allocateRxRemapEntry(in_msg));
            enqueue(network_reqOutPort, CHIRequestMsg, lat_req_bridge_2_nw) {
                out_msg               := in_msg;
                out_msg.requestor     := machineID;
                out_msg.fwdRequestor  := machineID;
                out_msg.Destination.add(tbe.haId);
            }
        }
        bwReqInPort.dequeue(clockEdge());
    }

    action(Fwd_ReqToBridge, desc="") {
        peek(reqRdyInPort, CHIRequestMsg) {
            enqueue(bridge_reqOutPort, CHIRequestMsg, lat_req_nw_2_bridge) {
                assert(is_valid(tbe));
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        reqRdyInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToBridge, desc="") {
        peek(datInPort, CHIDataMsg) {
            assert(is_valid(tbe));
            enqueue(bridge_datOutPort, CHIDataMsg, lat_dat_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
            // tbe.actions.pushNB?(clearTxTBE);
        }
        datInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToNW, desc="") { 
        peek(bwDatInPort, CHIDataMsg) {
            assert(is_valid(tbe));
            enqueue(network_datOutPort, CHIDataMsg, lat_dat_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        bwDatInPort.dequeue(clockEdge());
    }

    action(Fwd_CompAckToBridge, desc="") {
        peek(rspInPort, CHIResponseMsg) {
            assert(is_valid(tbe));
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Fwd_CompRspToNW, desc="") {
        DPRINTF(RubyCHIDebugStr5, "Action not impl\n");
        assert(false);
    }

    action(Fwd_CompAckRspToNW, desc="") {
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.haId);
            }
        }
        bwRspInPort.dequeue(clockEdge());
    }

    ////////////////////////////////////////////////////////////////////////////
    // Transitions
    ////////////////////////////////////////////////////////////////////////////
    transition(stable, AllocTxReqEntry, busy) {
        Alloc_TxReqEntry;
    }

    transition(stable, AllocRxReqEntry, busy) {
        Alloc_RxReqEntry;
    }

    transition(busy, Frm_NW_ReadData) {
        Fwd_DataToBridge;
    }

    transition(busy, Frm_d2d_ReadData) {
        Fwd_DataToNW;
    }

    transition(busy, FwdReqMsg) {
        Fwd_ReqToBridge;
    }

    transition(busy, Frm_NW_CompAck) {
        Fwd_CompAckToBridge;
    }

    transition(busy, Frm_d2d_Comp) {
        Fwd_CompRspToNW;
    }

    transition(busy, Frm_d2d_CompAck) {
        Fwd_CompAckRspToNW;
    }
}