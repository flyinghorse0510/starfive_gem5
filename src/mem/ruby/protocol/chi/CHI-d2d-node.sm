/*
 * Copyright (c) 2022 Starfive
 * All rights reserved
 */

machine(MachineType:D2DNode, "CHI interface to the D2D bridge") :

    // CHI network side channels
    MessageBuffer * reqIn,   network="From", virtual_network="0", vnet_type="none";
    MessageBuffer * snpIn,   network="From", virtual_network="1", vnet_type="none";
    MessageBuffer * rspIn,   network="From", virtual_network="2", vnet_type="none";
    MessageBuffer * datIn,   network="From", virtual_network="3", vnet_type="response";

    MessageBuffer * reqOut,   network="To", virtual_network="0", vnet_type="none";
    MessageBuffer * snpOut,   network="To", virtual_network="1", vnet_type="none";
    MessageBuffer * rspOut,   network="To", virtual_network="2", vnet_type="none";
    MessageBuffer * datOut,   network="To", virtual_network="3", vnet_type="response";

    // CHI bridge side channels
    MessageBuffer * d2dnode_reqIn;
    MessageBuffer * d2dnode_snpIn;
    MessageBuffer * d2dnode_rspIn;
    MessageBuffer * d2dnode_datIn;

    MessageBuffer * d2dnode_reqOut;
    MessageBuffer * d2dnode_snpOut;
    MessageBuffer * d2dnode_rspOut;
    MessageBuffer * d2dnode_datOut;

    // Send credits (for back pressure) for d2d node
    MessageBuffer * d2dnode_crdOut;

    // Accepted requests
    MessageBuffer * reqRdy;

    // Trigger queue for internal events
    MessageBuffer * triggerQueue;

    // Remap table allocation latency
    int allocation_latency  := 1;

    // Bridge --> NW latencies
    int lat_req_bridge_2_nw := 1;
    int lat_rsp_bridge_2_nw := 1;
    int lat_snp_bridge_2_nw := 1;
    int lat_dat_bridge_2_nw := 1;

    // NW --> Bridge NW latencies
    int lat_req_nw_2_bridge := 1;
    int lat_rsp_nw_2_bridge := 1;
    int lat_snp_nw_2_bridge := 1;
    int lat_dat_nw_2_bridge := 1;

    // Number of REMAP entries
    int num_txremap_entries := 8;
    int num_rxremap_entries := 8;

    int data_channel_size;

    int lat_crd_transfer := 1;

    // Src and Dst die Ids
    int src_die_id := 0;
    int dst_die_id := 1;
    
{
    // Cache block size
    int blockSize, default="RubySystem::getBlockSizeBytes()";

    state_declaration(State, default="D2DNode_State_null") {
        // Null state for debugging
        null,         AccessPermission:Invalid,     desc="Null state";
        busy,         AccessPermission:Invalid,     desc="A tracker entry has been allocated, so the transaction is progress";
        stable,       AccessPermission:Invalid,     desc="Stable but invalid, no ongoing transactions";
    }
    
    ////////////////////////////////////////////////////////////////////////////
    // Events
    ////////////////////////////////////////////////////////////////////////////
    enumeration(Event) {
        AllocTxReqEntry,     desc="Allocate a Tx Remap entry";
        AllocRxReqEntry,     desc="Allocate a Rx Remap entry";

        Frm_NW_ReadData,     desc="Dat Rsp to a Read Data from NW";
        Frm_NW_WriteData,    desc="Dat Rsp to a Write Data from NW";
        Frm_NW_SnpData,      desc="Dat Rsp to a Snp Data from NW";

        Frm_d2d_ReadData,    desc="Dat Rsp to a Read Data from d2d";
        Frm_d2d_WriteData,   desc="Dat Rsp to a Write Data from d2d";
        Frm_d2d_SnpData,     desc="Dat Rsp to a Snp Data from d2d";

        Frm_NW_Comp,         desc="Comp Rsp from NW side";
        Frm_NW_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_NW_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_NW_CompAck,      desc="CompAck Rsp from NW side";
        Frm_NW_SnpResp,      desc="SnpRsp from NW side";
        Frm_NW_RetryAck,     desc="RetryAck from NW side";
        Frm_NW_PCrdGrant,    desc="PCrdGrant from NW side";

        Frm_d2d_Comp,         desc="Comp Rsp from NW side";
        Frm_d2d_CompDBIDResp, desc="CompDBID Rsp from NW side";
        Frm_d2d_DBIDResp,     desc="DBID Rsp from NW side";
        Frm_d2d_CompAck,      desc="CompAck Rsp from NW side";
        Frm_d2d_SnpResp,      desc="SnpRsp from NW side";
        Frm_d2d_RetryAck,     desc="RetryAck from NW side";
        Frm_d2d_PCrdGrant,    desc="PCrdGrant from NW side";

        Frm_NW_Req,            desc="Fwd to D2DBridge";
        
        DeAllocTxReqEntry,   desc="Finalize event";
        DeAllocRxReqEntry,   desc="Finalize event";

        null,                desc="";
    }

    ////////////////////////////////////////////////////////////////////////////
    // Structure
    ////////////////////////////////////////////////////////////////////////////

    enumeration(TrackerType) {
        TX_req, desc="Tx REQ tracker";
        RX_req, desc="Rx REQ tracker";
        TX_snp, desc="Tx SNP tracker";
        RX_snp, desc="Rx SNP tracker";
    }

    structure(TriggerQueue, external ="yes") {
        Event front();
        Event back();
        bool frontNB();
        bool backNB();
        bool empty();
        void push(Event);
        void pushNB(Event);
        void pushFront(Event);
        void pushFrontNB(Event);
        void pop();
        void clear();
    }

    structure(TriggerMsg, desc="...", interface="Message") {
        Addr        addr;
        Event       event;
        TrackerType tbe_type;

        bool functionalRead(Packet *pkt) { return false; }
        bool functionalRead(Packet *pkt, WriteMask &mask) { return false; }
        bool functionalWrite(Packet *pkt) { return false; }
    }

    structure(TBE, desc="Common structure for Tx and Rx Table Entry") {
        State state,              desc="Once allocated, the state must be always busy";
        Addr addr,                desc="Address corresponding to this request";
        
        /* Generated by the originating requestor */
        MachineID o_src_id,       desc="d2d Src Id, Requestor HNF";
        MachineID o_fwd_src_id,   desc="d2d fwd Src Id, Fwd Requestor";
        MachineID haId,           desc="HA Id, that serves as the destion for requests and CompAcks";
        int storSlot,             desc="Slot in the storage tracker occupied by this entry";

        /* Type of TBE */
        bool is_req_tx,           desc="REQ Tx entry";
        bool is_req_rx,           desc="REQ Rx entry";
        bool is_snp_tx,           desc="SNP Tx entry";
        bool is_snp_rx,           desc="SNP Rx entry";
        
        // Unused fields to appease the SLICC compiler
        TriggerQueue actions,     template="<D2DNode_Event>", desc="List of actions";
        Event slicchack1,         desc="fix compiler not including headers";
    }

    structure(TBETable, external ="yes") {
        TBE lookup(Addr);
        void allocate(Addr);
        void deallocate(Addr);
        bool isPresent(Addr);
    }

    structure(TBEStorage, external ="yes") {
        int size();
        int capacity();
        int reserved();
        int addEntryToNewSlot();
        bool areNSlotsAvailable(int n);
        void incrementReserved();
        void decrementReserved();
        void removeEntryFromSlot(int slot);
    }

    TBETable TxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_txremap_entries";
    TBEStorage storTxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_txremap_entries";
    
    TBETable RxReqMapTable,       template="<D2DNode_TBE>",constructor="m_num_rxremap_entries";
    TBEStorage storRxReqMapTable, constructor="this, TBEType_to_string(TBEType_D2DRemap), m_num_rxremap_entries";

    ////////////////////////////////////////////////////////////////////////////
    // Interface functions required by SLICC
    ////////////////////////////////////////////////////////////////////////////
    State getState(TBE tbe, Addr addr) {
        if (is_valid(tbe)) {
            assert(tbe.state == State:busy);
            return tbe.state;
        } else {
            return State:stable;
        }
    }

    void setState(TBE tbe, Addr addr, State state) {
        if (is_valid(tbe)) {
            tbe.state := state;
        }
    }
    
    void setAccessPermission(Addr txnId, State state) {}

    AccessPermission getAccessPermission(Addr txnId) {}

    void functionalRead(Addr txnId, Packet *pkt, WriteMask &mask) {}

    int functionalWrite(Addr txnId, Packet *pkt) {}

    ////////////////////////////////////////////////////////////////////////////
    // Commonly defined functions
    ////////////////////////////////////////////////////////////////////////////
    include "CHI-d2d-funcs.sm";

    ////////////////////////////////////////////////////////////////////////////
    // Used by this module
    ////////////////////////////////////////////////////////////////////////////
    
    TBE getTxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (TxReqMapTable.isPresent(addr)) {
            return TxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getRxReqMapEntry(Addr addr), return_by_pointer="yes" {
        if (RxReqMapTable.isPresent(addr)) {
            return RxReqMapTable.lookup(addr);
        } else {
            return OOD;
        }
    }

    TBE getActiveTBE(Addr addr, TrackerType tbe_type), return_by_pointer="yes" {
        if (tbe_type == TrackerType:TX_req) {
            TBE tbe := getTxReqMapEntry(addr);
            assert(is_valid(tbe));
            return tbe;
        } else if (tbe_type == TrackerType:RX_req) {
            TBE tbe := getRxReqMapEntry(addr);
            assert(is_valid(tbe));
            return tbe;
        } else {
            error("Invalid/Unsupported Tracker Type");
        }
    }

    TBE allocateRxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storRxReqMapTable.decrementReserved();
        assert(storRxReqMapTable.areNSlotsAvailable(1));

        Addr addr          := in_msg.addr;
        
        RxReqMapTable.allocate(addr);
        TBE tbe           := RxReqMapTable[addr];

        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.haId          := getHANodeIdOnDie(addr);
        tbe.storSlot      := storRxReqMapTable.addEntryToNewSlot();

        return tbe;
    }

    TBE allocateTxRemapEntry(CHIRequestMsg in_msg), return_by_pointer="yes" {
        storTxReqMapTable.decrementReserved();
        assert(storTxReqMapTable.areNSlotsAvailable(1));

        // Create a new txn_id from the src die
        Addr addr := in_msg.addr;

        // Allocate a TBE entry
        TxReqMapTable.allocate(addr);
        TBE tbe := TxReqMapTable[addr];

        // Save the original/incoming src_id and txn_id
        tbe.addr          := addr;
        tbe.o_src_id      := in_msg.requestor;
        tbe.o_fwd_src_id  := in_msg.fwdRequestor;
        tbe.storSlot      := storTxReqMapTable.addEntryToNewSlot();


        return tbe;
    }

    ////////////////////////////////////////////////////////////////////////////
    // Outbound Ports
    ////////////////////////////////////////////////////////////////////////////
    out_port(network_reqOutPort, CHIRequestMsg,  reqOut);
    out_port(network_snpOutPort, CHIRequestMsg,  snpOut);
    out_port(network_rspOutPort, CHIResponseMsg, rspOut);
    out_port(network_datOutPort, CHIDataMsg,     datOut);
    out_port(reqRdyOutPort, CHIRequestMsg, reqRdy);
    out_port(bridge_reqOutPort, CHIRequestMsg,  d2dnode_reqOut);
    out_port(bridge_snpOutPort, CHIRequestMsg,  d2dnode_snpOut);
    out_port(bridge_rspOutPort, CHIResponseMsg, d2dnode_rspOut);
    out_port(bridge_datOutPort, CHIDataMsg,     d2dnode_datOut);
    out_port(triggerOutPort, TriggerMsg, triggerQueue);
    out_port(d2dCrdOutPort, D2DCrMsg, d2dnode_crdOut);

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from NW)
    ////////////////////////////////////////////////////////////////////////////
    in_port(reqInPort, CHIRequestMsg, reqIn, rank=1) {
        if (reqInPort.isReady(clockEdge())) {
            peek(reqInPort, CHIRequestMsg) {
                trigger(Event:AllocTxReqEntry, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(reqRdyInPort, CHIRequestMsg, reqRdy, rank=2) {
        if (reqRdyInPort.isReady(clockEdge())) {
            peek(reqRdyInPort, CHIRequestMsg) {
                trigger(Event:Frm_NW_Req, in_msg.addr, getTxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(datInPort, CHIDataMsg, datIn, rank=3) {
        if (datInPort.isReady(clockEdge())) {
            peek(datInPort, CHIDataMsg) {
                // This must be in response of D2DNode generated request
                // which in turn must be generated in response to a
                // request recvd from the D2DBrdige.
                assert((in_msg.bitMask.count() <= data_channel_size) && (in_msg.bitMask.count() > 0));
                Event evt := frm_nw_dataToEvent(in_msg.type);
                if (evt == Event:Frm_NW_ReadData) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_WriteData) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_SnpData) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                }
            }
        }
    }

    in_port(rspInPort, CHIResponseMsg, rspIn, rank=4) {
        if (rspInPort.isReady(clockEdge())) {
            peek(rspInPort, CHIResponseMsg) {
                Event evt := frm_nw_rspToEvent(in_msg.type);
                if (evt == Event:Frm_NW_Comp) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_CompAck) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_NW_SnpResp) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                } else if ((evt == Event:Frm_NW_RetryAck) ||
                           (evt == Event:Frm_NW_PCrdGrant)) {
                    DPRINTF(RubyCHIDebugStr5, "RetryAck and PCRdGrant to do\n");
                    assert(false);
                }
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Inbound Ports (from D2DBridge)
    ////////////////////////////////////////////////////////////////////////////
    in_port(bwReqInPort, CHIRequestMsg, d2dnode_reqIn, rank=20) {
        if (bwReqInPort.isReady(clockEdge())) {
            peek(bwReqInPort, CHIRequestMsg) {
                trigger(Event:AllocRxReqEntry, in_msg.addr, getRxReqMapEntry(in_msg.addr));
            }
        }
    }

    in_port(bwDatInPort, CHIDataMsg, d2dnode_datIn, rank=21) {
        if (bwDatInPort.isReady(clockEdge())) {
            peek(bwDatInPort, CHIDataMsg) {
                Event evt := frm_d2d_dataToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_ReadData) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_WriteData) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_SnpData) {
                    DPRINTF(RubyCHIDebugStr5, "SNP tracker entries to do\n");
                    assert(false);
                }
            }
        }
    }

    in_port(bwRspInPort, CHIResponseMsg, d2dnode_rspIn, rank=22) {
        if (bwRspInPort.isReady(clockEdge())) {
            peek(bwRspInPort, CHIResponseMsg) {
                Event evt := frm_d2d_rspToEvent(in_msg.type);
                if (evt == Event:Frm_d2d_Comp) {
                    TBE tbe := getTxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else if (evt == Event:Frm_d2d_CompAck) {
                    TBE tbe := getRxReqMapEntry(in_msg.addr);
                    assert(is_valid(tbe));
                    trigger(evt, in_msg.addr, tbe);
                } else {
                    DPRINTF(RubyCHIDebugStr5, "D2D Rsp type TODO = %s\n",in_msg);
                    assert(false);
                }
            }
        }
    }

    in_port(triggerInPort, Trigger, triggerQueue, rank=23) {
        if(triggerInPort.isReady(clockEdge())) {
            peek(triggerInPort, TriggerMsg) {
                trigger(in_msg.event, in_msg.addr, getActiveTBE(in_msg.addr,in_msg.tbe_type));
            }
        }
    }

    ////////////////////////////////////////////////////////////////////////////
    // Actions
    ////////////////////////////////////////////////////////////////////////////
    action(Alloc_TxReqEntry, desc="") {
        if (storTxReqMapTable.areNSlotsAvailable(1)) {
            storTxReqMapTable.incrementReserved();
            peek(reqInPort, CHIRequestMsg) {
                set_tbe(allocateTxRemapEntry(in_msg));
                enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
                    out_msg := in_msg;
                }
            }
        } 
        else {
            DPRINTF(RubyCHIDebugStr5, "Retry not implement");
            assert(false);
        }
        reqInPort.dequeue(clockEdge());
    }

    action(Alloc_RxReqEntry, desc="") {
        /**
         * We do not have to send retries
         * for the REQs received from the
         * bridge side, so create a resource
         * stall
         */
        check_allocate(storRxReqMapTable);
        storRxReqMapTable.incrementReserved();
        peek(bwReqInPort, CHIRequestMsg) {
            set_tbe(allocateRxRemapEntry(in_msg));
            enqueue(network_reqOutPort, CHIRequestMsg, lat_req_bridge_2_nw) {
                out_msg               := in_msg;
                out_msg.requestor     := machineID;
                out_msg.fwdRequestor  := machineID;
                out_msg.Destination.add(tbe.haId);
            }
        }
        bwReqInPort.dequeue(clockEdge());
    }

    action(Fwd_ReqToBridge, desc="") {
        peek(reqRdyInPort, CHIRequestMsg) {
            enqueue(bridge_reqOutPort, CHIRequestMsg, lat_req_nw_2_bridge) {
                assert(is_valid(tbe));
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        reqRdyInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToBridge, desc="") {
        peek(datInPort, CHIDataMsg) {
            assert(is_valid(tbe));
            enqueue(bridge_datOutPort, CHIDataMsg, lat_dat_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
            // tbe.actions.pushNB?(clearTxTBE);
        }
        datInPort.dequeue(clockEdge());
    }

    action(Fwd_DataToNW, desc="") { 
        assert(is_valid(tbe));
        peek(bwDatInPort, CHIDataMsg) {
            enqueue(network_datOutPort, CHIDataMsg, lat_dat_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        bwDatInPort.dequeue(clockEdge());
    }

    action(Fwd_CompAckToBridge, desc="") {
        assert(is_valid(tbe));
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        enqueue(triggerOutPort, TriggerMsg, 0) {
            out_msg.addr     := tbe.addr;
            out_msg.event    := Event:DeAllocTxReqEntry;
            out_msg.tbe_type := TrackerType:TX_req;
        }
        rspInPort.dequeue(clockEdge());
    }

    action(Fwd_CompRspToNW, desc="") {
        assert(is_valid(tbe));
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.o_src_id);
            }
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Fwd_CompAckToNW, desc="") {
        peek(bwRspInPort, CHIResponseMsg) {
            enqueue(network_rspOutPort, CHIResponseMsg, lat_rsp_bridge_2_nw) {
                out_msg := in_msg;
                out_msg.responder := machineID;
                out_msg.Destination.add(tbe.haId);
            }
        }
        enqueue(triggerOutPort, TriggerMsg, 0) {
            out_msg.addr     := tbe.addr;
            out_msg.event    := Event:DeAllocRxReqEntry;
            out_msg.tbe_type := TrackerType:RX_req;
        }
        bwRspInPort.dequeue(clockEdge());
    }

    action(Send_D2DCredit, desc="Send credits to the D2DBridge") {
        enqueue(d2dCrdOutPort, D2DCrMsg, lat_crd_transfer) {
            out_msg.cr_inc := true;
        }
    }

    action(De_AllocTxReqEntry, desc="Deallocate Tx Remap entries") {
        assert(is_valid(tbe));
        storTxReqMapTable.removeEntryFromSlot(tbe.storSlot);
        TxReqMapTable.deallocate(address);
        // TODO: Process retry when implemented.
    }

    action(De_AllocRxReqEntry, desc="") {
        assert(is_valid(tbe));
        storRxReqMapTable.removeEntryFromSlot(tbe.storSlot);
        RxReqMapTable.deallocate(address);
    }

    action(popTriggerQueue, desc="Pop trigger queue.") {
        triggerInPort.dequeue(clockEdge());
    }

    action(Fwd_CompToBridge, desc="Fwd rsp to D2D Bridge") {
        peek(rspInPort, CHIResponseMsg) {
            enqueue(bridge_rspOutPort, CHIResponseMsg, lat_rsp_nw_2_bridge) {
                out_msg := in_msg;
                out_msg.Destination.remove(machineID);
            }
        }
        rspInPort.dequeue(clockEdge());
    }

    ////////////////////////////////////////////////////////////////////////////
    // Transitions
    ////////////////////////////////////////////////////////////////////////////
    transition(stable, AllocTxReqEntry, busy) {
        Alloc_TxReqEntry;
    }

    transition(stable, AllocRxReqEntry, busy) {
        Alloc_RxReqEntry;
        Send_D2DCredit;
    }

    transition(busy, Frm_NW_ReadData) {
        Fwd_DataToBridge;
    }

    transition(busy, Frm_d2d_ReadData) {
        Fwd_DataToNW;
        Send_D2DCredit;
    }

    transition(busy, Frm_NW_Req) {
        Fwd_ReqToBridge;
    }

    transition(busy, Frm_NW_Comp) {
        Fwd_CompToBridge;
    }

    transition(busy, Frm_NW_CompAck) {
        Fwd_CompAckToBridge;
    }

    transition(busy, Frm_d2d_Comp) {
        Fwd_CompRspToNW;
        Send_D2DCredit;
    }

    transition(busy, Frm_d2d_CompAck) {
        Fwd_CompAckToNW;
        Send_D2DCredit;
    }

    transition(busy, DeAllocTxReqEntry, stable) {
        De_AllocTxReqEntry;
        popTriggerQueue;
    }

    transition(busy, DeAllocRxReqEntry, stable) {
        De_AllocRxReqEntry;
        popTriggerQueue;
    }
}