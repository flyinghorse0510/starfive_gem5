/*
 * Copyright (c) 2023 Starfive
 * All rights reserved
 */

////////////////////////////////////////////////////////////////////////////
// CHI-ha actions definitions
////////////////////////////////////////////////////////////////////////////

action(Initiate_ReadNoSnp, desc="") {
  tbe.actions.push(Event:SendReadNoSnp);
  tbe.actions.push(Event:WaitCompAck);
  tbe.actions.pushNB(Event:SendCompData);
}

action(Initiate_ReadUnique_Miss, desc="") {
  assert(is_HN);
  tbe.actions.push(Event:SendReadNoSnp);
  tbe.actions.push(Event:WaitCompAck);
  tbe.actions.pushNB(Event:SendCompData);
}

action(ProcessNextState, desc="") {
  assert(is_valid(tbe));
  processNextState(address, tbe);
}

action(ProcessNextState_ClearPending, desc="") {
  assert(is_valid(tbe));
  clearPendingAction(tbe); //ADD-FUNC: clearPendingAction
  processNextState(address, tbe);
}

action(Pop_TriggerQueue, desc="") {
  triggerInPort.dequeue(clockEdge());
}

action(AllocateTBE_Request, desc="") {
  if (storTBEs.areNSlotsAvailable(1)) {  
    // reserve a slot for this request
    storTBEs.incrementReserved();

    // Move request to rdy queue
    peek(reqInPort, CHIRequestMsg) {
      enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
        assert(in_msg.addr == address);
        assert(in_msg.is_local_pf == false);
        out_msg := in_msg;
      }
    }
  } else {
    // we don't have resources to track this request; enqueue a retry
    peek(reqInPort, CHIRequestMsg) {
      assert(in_msg.allowRetry);
      enqueue(retryTriggerOutPort, RetryTriggerMsg, 0) {
        out_msg.addr := in_msg.addr;
        out_msg.usesTxnId := false;
        out_msg.event := Event:SendRetryAck;
        out_msg.retryDest := in_msg.requestor;
        retryQueue.emplace_retry(in_msg.addr,false,in_msg.requestor);
      }
    }
  }
  reqInPort.dequeue(clockEdge());
}

action(AllocateTBE_Request_WithCredit, desc="") {
  // TBE slot already reserved
  // Move request to rdy queue
  peek(reqInPort, CHIRequestMsg) {
    assert(in_msg.allowRetry == false);
    enqueue(reqRdyOutPort, CHIRequestMsg, allocation_latency) {
      assert(in_msg.addr == address);
      out_msg := in_msg;
    }
  }
  reqInPort.dequeue(clockEdge());
}

action(Initiate_Request, desc="") {
    State initial := getState(tbe, address);
    bool was_retried := false;
    peek(reqRdyPort, CHIRequestMsg) {
      set_tbe(allocateRequestTBE(address, in_msg));
      // only a msg that was already retried doesn't allow a retry
      was_retried := in_msg.allowRetry == false;
    }
    DirEntry dir_entry := getDirEntry(address);
    copyDir(dir_entry, tbe, initial);
    tbe.use_DMT := is_HN && enable_DMT;
    tbe.use_DCT := enable_DCT;

    // For HA there is no LLC, always drop the data
    tbe.dataToBeInvalid := true;
    tbe.doCacheFill := false;

    // Requires a DirEntry allocation
    tbe.requiresDirEntryAlloc := (is_invalid(dir_entry)) && requiresDirEntry(tbe.reqType);
    bool avail_direntry := directory.cacheAvail(address);
    bool doSnoopFilterFill := !directory.allowInfiniteEntries() && requiresDirEntry(tbe.reqType);
    assert(avail_direntry || (!doSnoopFilterFill));
    if (tbe.requiresDirEntryAlloc) {
      directory.allocate(address, new DirEntry);
      directory.profileAlloc();
    }
    if ((is_valid(dir_entry)) && requiresDirEntry(tbe.reqType)) {
      directory.profileHit();
    }

    incomingTransactionStart(address, curTransitionEvent(), initial, was_retried);
}

action(Send_ReadNoSnp, desc="") {
  assert(is_HN);
  assert(tbe.use_DMT == false);

  clearExpectedReqResp(tbe);
  tbe.expected_req_resp.addExpectedDataType(CHIDataType:CompData_UC);
  // NOTE: the first CompData received counts as RespSepData
  tbe.expected_req_resp.addExpectedRespType(CHIResponseType:RespSepData);
  tbe.expected_req_resp.setExpectedCount(2);
  tbe.dataBlkValid.clear();
  outgoingTransactionStart(address, curTransitionEvent());

  enqueue(reqOutPort, CHIRequestMsg, request_latency) {
    prepareRequest(tbe, CHIRequestType:ReadNoSnp, out_msg);
    out_msg.Destination.add(mapAddressToDownstreamMachine(tbe.addr));
    out_msg.dataToFwdRequestor := false;
    allowRequestRetry(tbe, out_msg);
  }
}

action(Send_WriteNoSnp, desc="") {
  assert(is_valid(tbe));

  enqueue(reqOutPort, CHIRequestMsg, request_latency) {
    prepareRequest(tbe, CHIRequestType:WriteNoSnp, out_msg);
    out_msg.Destination.add(mapAddressToDownstreamMachine(tbe.addr));
    allowRequestRetry(tbe, out_msg);
  }
  // allow to expect this on top of data coming from upstream;
  // so addExpectedCount
  tbe.expected_req_resp.addExpectedRespType(CHIResponseType:CompDBIDResp);
  tbe.expected_req_resp.addExpectedCount(1);
}

action(ExpectCompAck, desc="") {
  assert(is_valid(tbe));
  tbe.expected_req_resp.addExpectedRespType(CHIResponseType:CompAck);
  tbe.expected_req_resp.addExpectedCount(1);
}

action(Receive_ReqDataResp, desc="") {
  assert(is_valid(tbe));
  assert(tbe.expected_req_resp.hasExpected());
  peek(datInPort, CHIDataMsg) {
    // Decrement pending
    if (tbe.expected_req_resp.receiveData(in_msg.type) == false) {
      error("Received unexpected message");
    }
    // Copy data to tbe only if we didn't have valid data or the received
    // data is dirty
    if ((tbe.dataBlkValid.isFull() == false) ||
        (in_msg.type == CHIDataType:CompData_UD_PD) ||
        (in_msg.type == CHIDataType:CompData_SD_PD) ||
        (in_msg.type == CHIDataType:CBWrData_UD_PD) ||
        (in_msg.type == CHIDataType:CBWrData_SD_PD) ||
        (in_msg.type == CHIDataType:NCBWrData)) {
      // clear mask if started to receive new data
      if(tbe.dataBlkValid.isFull()){
        tbe.dataBlkValid.clear();
      }
      tbe.dataBlk.copyPartial(in_msg.dataBlk, in_msg.bitMask);
      assert(tbe.dataBlkValid.isOverlap(in_msg.bitMask) == false);
      tbe.dataBlkValid.orMask(in_msg.bitMask);
    }
  }
}

action(Receive_RespSepDataFromCompData, desc="") {
  assert(is_valid(tbe));
  assert(tbe.expected_req_resp.hasExpected());
  // check if a previous CompData msg already counted as a RespSepData
  if (tbe.expected_req_resp.receivedRespType(CHIResponseType:RespSepData) == false) {
    if (tbe.expected_req_resp.receiveResp(CHIResponseType:RespSepData) == false) {
      error("Received unexpected message");
    }
    if (is_HN == false) {
      // must now ack the responder
      tbe.actions.pushFrontNB(Event:SendCompAck);
    }
  }
}

action(StallRequest, desc="") {
  // was stalled because of an existing request
  assert(is_valid(tbe));
  assert(tbe.addr == address);
  // tracks pending
  tbe.wakeup_pending_req := true;
  stall_and_wait(reqRdyPort, address);
}

action(Initiate_ReadShared_HitUpstream, desc="") {
  tbe.actions.push(Event:SendSnpShared);
  tbe.actions.push(Event:WaitCompAck);
  tbe.actions.pushNB(Event:SendCompData);
}

action(Initiate_ReadShared_HitUpstream_NoOwner, desc="") {
  tbe.actions.push(Event:SendSnpOnce);
  tbe.actions.push(Event:WaitCompAck);
  tbe.actions.pushNB(Event:SendCompData);
}

action(UpdateDataState_FromReqDataResp, desc="") {
  assert(is_valid(tbe));
  // only perform the update once we received all chunks
  if (tbe.expected_req_resp.hasReceivedData()) {
    assert(tbe.dataBlkValid.isFull());
    peek(datInPort, CHIDataMsg) {

      if ((in_msg.type == CHIDataType:CompData_UC) ||
          (in_msg.type == CHIDataType:DataSepResp_UC)) {
        assert(tbe.dataUnique == false);
        assert((tbe.dataValid && tbe.dataDirty) == false);
        tbe.dataDirty := false;
        tbe.dataUnique := true;
        tbe.dataValid := true;
        assert(tbe.dataMaybeDirtyUpstream == false);

      } else if (in_msg.type == CHIDataType:CompData_UD_PD) {
        assert(tbe.dataUnique == false);
        assert((tbe.dataValid && tbe.dataDirty) == false);
        tbe.dataDirty := true;
        tbe.dataUnique := true;
        tbe.dataValid := true;
        assert(tbe.dataMaybeDirtyUpstream == false);

      } else if (in_msg.type == CHIDataType:CompData_SC) {
        assert(tbe.dataUnique == false);
        assert((tbe.dataValid && tbe.dataDirty) == false);
        tbe.dataDirty := false;
        tbe.dataUnique := false;
        tbe.dataValid := true;
        assert(tbe.dataMaybeDirtyUpstream == false);

      } else if (in_msg.type == CHIDataType:CompData_SD_PD) {
        assert(tbe.dataUnique == false);
        assert((tbe.dataValid && tbe.dataDirty) == false);
        tbe.dataDirty := true;
        tbe.dataUnique := false;
        tbe.dataValid := true;
        assert(tbe.dataMaybeDirtyUpstream == false);

      } else if (in_msg.type == CHIDataType:CompData_I) {
        tbe.dataValid := true;
        tbe.dataToBeInvalid := true;
        assert(tbe.dataMaybeDirtyUpstream == false);

      } else if (in_msg.type == CHIDataType:CBWrData_UC) {
        assert(tbe.dataUnique);
        tbe.dataMaybeDirtyUpstream := false;
        tbe.dataValid := true;

      } else if (in_msg.type == CHIDataType:CBWrData_SC) {
        // stale WB, nothing to do ??

      } else if (in_msg.type == CHIDataType:CBWrData_UD_PD) {
        assert(tbe.dataUnique);
        tbe.dataDirty := true;
        tbe.dataValid := true;
        if (tbe.reqType == CHIRequestType:WriteCleanFull) {
          // upstream data can still be UC if this is a WriteCleanFull
          assert(tbe.dir_ownerExists && tbe.dir_ownerIsExcl);
          tbe.dataMaybeDirtyUpstream := true;
        } else {
          tbe.dataMaybeDirtyUpstream := false;
        }

      } else if (in_msg.type == CHIDataType:CBWrData_SD_PD) {
        tbe.dataDirty := true;
        tbe.dataValid := true;
        tbe.dataMaybeDirtyUpstream := false;

      } else if (in_msg.type == CHIDataType:CBWrData_I) {
        // stale WB, nothing to do ??

      } else {
        error("Unsuported data type");
      }
    }
  }
  printTBEState(tbe);
}

action(UpdateDirState_FromReqResp, desc="") {
  peek(rspInPort, CHIResponseMsg) {
    if ((in_msg.type == CHIResponseType:CompAck) && tbe.updateDirOnCompAck) {
      assert(tbe.requestor == in_msg.responder);

      tbe.dir_sharers.add(in_msg.responder);

      if (tbe.requestorToBeOwner) {
        assert(tbe.dataMaybeDirtyUpstream);
        assert(tbe.dir_ownerExists == false);
        assert(tbe.requestorToBeExclusiveOwner == false);
        tbe.dir_owner := in_msg.responder;
        tbe.dir_ownerExists := true;
        tbe.dir_ownerIsExcl := false;

      } else if (tbe.requestorToBeExclusiveOwner) {
        assert(tbe.dataMaybeDirtyUpstream);
        assert(tbe.dir_ownerExists == false);
        assert(tbe.dir_sharers.count() == 1);
        tbe.dir_owner := in_msg.responder;
        tbe.dir_ownerExists := true;
        tbe.dir_ownerIsExcl := true;
      }
    }
  }
  printTBEState(tbe);
}

action(UpdateDirState_FromReqDataResp, desc="") {
  assert(is_valid(tbe));
  // only perform the update once we received all chunks
  if (tbe.expected_req_resp.hasReceivedData()) {
    assert(tbe.dataBlkValid.isFull());
    peek(datInPort, CHIDataMsg) {

      if (in_msg.type == CHIDataType:CBWrData_UC) {
        assert(tbe.dir_ownerExists && tbe.dir_ownerIsExcl && (tbe.dir_owner == in_msg.responder));
        assert(tbe.dir_sharers.isElement(in_msg.responder));
        tbe.dir_ownerExists := false;
        tbe.dir_ownerIsExcl := false;
        tbe.dir_sharers.remove(in_msg.responder);

      } else if (in_msg.type == CHIDataType:CBWrData_UD_PD) {
        assert(tbe.dir_ownerExists && tbe.dir_ownerIsExcl && (tbe.dir_owner == in_msg.responder));
        assert(tbe.dir_sharers.isElement(in_msg.responder));
        if (tbe.reqType != CHIRequestType:WriteCleanFull) {
          tbe.dir_ownerExists := false;
          tbe.dir_ownerIsExcl := false;
          tbe.dir_sharers.remove(in_msg.responder);
        }

      } else if (in_msg.type == CHIDataType:CBWrData_SC) {
        assert((tbe.dir_ownerExists == false) || (tbe.dir_owner != in_msg.responder));
        // Do not remove the responder in case of stale WriteCleanFull
        if (tbe.reqType != CHIRequestType:WriteCleanFull) {
          tbe.dir_sharers.remove(in_msg.responder);
        }

      } else if (in_msg.type == CHIDataType:CBWrData_SD_PD) {
        assert(tbe.dir_ownerExists && (tbe.dir_ownerIsExcl == false) && (tbe.dir_owner == in_msg.responder));
        assert(tbe.dir_sharers.isElement(in_msg.responder));
        tbe.dir_ownerExists := false;
        tbe.dir_ownerIsExcl := false;
        if (tbe.reqType != CHIRequestType:WriteCleanFull) {
          tbe.dir_sharers.remove(in_msg.responder);
        }

      } else if (in_msg.type == CHIDataType:CBWrData_I) {
        // nothing to do here; just check
        assert((tbe.dir_ownerExists == false) || (tbe.dir_owner != in_msg.responder));
        assert(tbe.dir_sharers.isElement(in_msg.responder) == false);

      } else {
        error("Unsuported data type");
      }
    }
  }
}

action(Receive_ReqResp, desc="") {
  assert(tbe.expected_req_resp.hasExpected());
  peek(rspInPort, CHIResponseMsg) {
    // Decrement pending
    if (tbe.expected_req_resp.receiveResp(in_msg.type) == false) {
      error("Received unexpected message");
    }
    assert(in_msg.stale == tbe.is_stale);
  }
}

action(Initiate_Evict, desc="") {
  tbe.actions.push(Event:SendCompIResp);
}

action(Send_CompI, desc="") {
  assert(is_valid(tbe));

  // Used to ack Evict request
  assert(tbe.dir_sharers.isElement(tbe.requestor));
  assert((tbe.dir_ownerExists == false) || (tbe.dir_owner != tbe.requestor));

  tbe.dir_sharers.remove(tbe.requestor);

  enqueue(rspOutPort, CHIResponseMsg, response_latency) {
    out_msg.addr := address;
    out_msg.type := CHIResponseType:Comp_I;
    out_msg.responder := machineID;
    out_msg.Destination.add(tbe.requestor);
  }
}

action(Send_CompData, desc="") {
  assert(is_valid(tbe));
  assert(tbe.dataValid);

  bool is_rd_once := tbe.reqType == CHIRequestType:ReadOnce;
  bool is_rd_shared := (tbe.reqType == CHIRequestType:ReadShared) ||
                       (tbe.reqType == CHIRequestType:ReadNotSharedDirty);
  bool is_rd_nsd := tbe.reqType == CHIRequestType:ReadNotSharedDirty;
  bool is_rd_unique := tbe.reqType == CHIRequestType:ReadUnique;

  // if the config allows (or not caching the data) and line has no sharers
  bool snd_unique_on_rs := (fwd_unique_on_readshared || tbe.dataToBeInvalid)
                          && tbe.dataUnique && tbe.dir_sharers.isEmpty();
  // if the request type allows and we won't be caching the data
  bool snd_dirty_on_rs := is_rd_shared && !is_rd_nsd && tbe.dataToBeInvalid;

  if (is_rd_once) {
    tbe.snd_msgType := CHIDataType:CompData_I;
  } else if (is_rd_unique || (is_rd_shared && snd_unique_on_rs)) {
    assert(tbe.dataUnique);
    if (tbe.dataDirty) {
      tbe.snd_msgType := CHIDataType:CompData_UD_PD;
    } else {
      tbe.snd_msgType := CHIDataType:CompData_UC;
    }
  } else if (is_rd_shared) {
    if (tbe.dataDirty && snd_dirty_on_rs) {
      tbe.snd_msgType := CHIDataType:CompData_SD_PD;
    } else {
      // notice the MaintainCoherence will send WriteClean if the line
      // is dirty and we won't be caching the data
      tbe.snd_msgType := CHIDataType:CompData_SC;
    }
  } else {
    error("Invalid request type");
  }

  tbe.dataMaybeDirtyUpstream := tbe.dataMaybeDirtyUpstream ||
                            (tbe.snd_msgType == CHIDataType:CompData_UD_PD) ||
                            (tbe.snd_msgType == CHIDataType:CompData_SD_PD) ||
                            (tbe.snd_msgType == CHIDataType:CompData_UC);
  tbe.requestorToBeExclusiveOwner := tbe.requestorToBeExclusiveOwner ||
                            (tbe.snd_msgType == CHIDataType:CompData_UD_PD) ||
                            (tbe.snd_msgType == CHIDataType:CompData_UC);
  tbe.requestorToBeOwner := tbe.requestorToBeOwner ||
                            (tbe.snd_msgType == CHIDataType:CompData_SD_PD);

  tbe.snd_destination := tbe.requestor;
  setupPendingSend(tbe);
  printTBEState(tbe);
}

action(Send_Data, desc="") {
  assert(tbe.snd_pendEv);
  assert(tbe.snd_pendBytes.count() > 0);
  tbe.snd_pendEv := false;
  enqueue(datOutPort, CHIDataMsg, data_latency) {
    out_msg.addr := tbe.addr;
    out_msg.type := tbe.snd_msgType;

    int offset := tbe.snd_pendBytes.firstBitSet(true);
    assert(offset < blockSize);
    int range := tbe.snd_pendBytes.firstBitSet(false, offset) - offset;
    assert((range > 0) && (range <= blockSize));
    if (range > data_channel_size) {
      range := data_channel_size;
    }
    tbe.snd_pendBytes.setMask(offset, range, false);

    out_msg.dataBlk := tbe.dataBlk;
    out_msg.bitMask.setMask(offset, range);

    out_msg.responder := machineID;

    out_msg.Destination.add(tbe.snd_destination);
  }

  // send next chunk (if any) next cycle
  scheduleSendData(tbe, 1);
}

action(Initiate_CopyBack, desc="") {
  // expect to receive this data after Send_CompDBIDResp
  if (tbe.reqType == CHIRequestType:WriteBackFull) {
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_UD_PD);
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_SD_PD);
  } else if (tbe.reqType == CHIRequestType:WriteEvictFull) {
    assert(tbe.reqType == CHIRequestType:WriteEvictFull);
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_UC);
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_SC);
  } else {
    assert(tbe.reqType == CHIRequestType:WriteCleanFull);
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_UD_PD);
    tbe.expected_req_resp.addExpectedDataType(CHIDataType:CBWrData_SD_PD);
  }
  tbe.expected_req_resp.setExpectedCount(1);
  tbe.actions.pushNB(Event:SendCompDBIDResp);
  tbe.actions.push(Event:MaintainCoherence);
}

action(Send_CompDBIDResp, desc="") {
  assert(is_valid(tbe));
  enqueue(rspOutPort, CHIResponseMsg, response_latency) {
    out_msg.addr := address;
    out_msg.type := CHIResponseType:CompDBIDResp;
    out_msg.responder := machineID;
    out_msg.Destination.add(tbe.requestor);
  }
}

action(Finalize_UpdateDirectoryFromTBE, desc="") {
  assert(is_valid(tbe));
  State final := tbe.finalState;
  bool deallocDirEntry := false;
  if ((final == State:RSC) || (final == State:RSD) || (final == State:RUSC) || 
      (final == State:RUSD) || (final == State:RU)) {
    DirEntry dir_entry := getDirEntry(address);
    assert(is_valid(dir_entry));
    assert(tbe.dir_sharers.count() > 0);
    dir_entry.ownerExists := tbe.dir_ownerExists;
    dir_entry.ownerIsExcl := tbe.dir_ownerIsExcl;
    dir_entry.owner := tbe.dir_owner;
    dir_entry.sharers := tbe.dir_sharers;
  } else {
    assert((tbe.dir_ownerExists == false) && tbe.dir_sharers.isEmpty());
    if(directory.isTagPresent(address)) {
      deallocDirEntry := true;
    }
  }
  
  /** 
   * If you de-allocating the dirEntry, make
   * sure to reset the SnoopFilter way and 
   * wakeup any pending SnoopFilter repl.
   */
  if (deallocDirEntry) {
    resetDirEntryAndWakeupPendingSFRepl(address);
    directory.deallocate(address);
  }
}

action(Finalize_DeallocateRequest, desc="") {
  assert(is_valid(tbe));
  assert(tbe.actions.empty());
  wakeupPendingReqs(tbe);
  wakeupPendingTgrs(tbe);
  wakeupPendingSFRepl(tbe);
  if (tbe.is_req_tbe) {
    deallocateReqTBE(tbe);
    processRetryQueue();
  } else if (tbe.is_sfrepl_tbe) {
    deallocateSnoopFilterTBE(tbe);
  }
  unset_tbe();

  incomingTransactionEnd(address, curTransitionNextState());
}

action(Pop_ReqRdyQueue, desc="") {
  reqRdyPort.dequeue(clockEdge());
}

action(Pop_RespInQueue, desc="") {
  rspInPort.dequeue(clockEdge());
}

action(Pop_DataInQueue, desc="") {
  datInPort.dequeue(clockEdge());
}

action(Profile_OutgoingEnd_DataResp, desc="") {
  assert(is_valid(tbe));
  // completes once all data is received
  if (tbe.expected_req_resp.hasReceivedData()) {
    outgoingTransactionEnd(address, tbe.rcvdRetryAck);
  }
}

action(Send_CompUC, desc="") {
  assert(is_valid(tbe));
  enqueue(rspOutPort, CHIResponseMsg, response_latency) {
    out_msg.addr := address;
    out_msg.type := CHIResponseType:Comp_UC;
    out_msg.responder := machineID;
    out_msg.Destination.add(tbe.requestor);
  }
}

action(Send_CompUC_Stale, desc="") {
  assert(is_valid(tbe));
  enqueue(rspOutPort, CHIResponseMsg, response_latency) {
    out_msg.addr := address;
    out_msg.type := CHIResponseType:Comp_UC;
    out_msg.responder := machineID;
    out_msg.Destination.add(tbe.requestor);
    // We don't know if this is a stale clean unique or a bug, so flag the
    // reponse so the requestor can make further checks
    out_msg.stale := true;
  }
}

action(Send_SnpCleanInvalid_NoReq, desc="") {
  assert(is_valid(tbe));
  assert(tbe.expected_snp_resp.hasExpected() == false);
  enqueue(snpOutPort, CHIRequestMsg, snoop_latency) {
    prepareRequest(tbe, CHIRequestType:SnpCleanInvalid, out_msg);
    out_msg.Destination.addNetDest(tbe.dir_sharers);
    out_msg.Destination.remove(tbe.requestor);
    // at least one sharer other than requestor
    assert(out_msg.Destination.count() > 0);
    out_msg.retToSrc := false;
    setExpectedForInvSnoop(tbe, false);
    tbe.expected_snp_resp.setExpectedCount(out_msg.Destination.count());
  }
}

action(Initiate_CleanUnique, desc="") {
  // invalidates everyone except requestor
  if (tbe.dir_sharers.count() > 1) {
    tbe.actions.push(Event:SendSnpCleanInvalidNoReq);
  }
  // auto upgrade if HN
  tbe.dataUnique := true;

  // next actions will depend on the data state after snoops+CleanUnique
  tbe.actions.push(Event:FinishCleanUnique);
}

action(Finish_CleanUnique, desc="") {
  // This is should be executed at the end of a transaction
  assert(tbe.actions.empty());

  // everyone may have been hit by an invalidation so check again
  if (tbe.dir_sharers.isElement(tbe.requestor) == false) {
    tbe.updateDirOnCompAck := false;
    assert(tbe.dataValid == false);
    assert(tbe.is_stale);
    tbe.is_stale := false;
    tbe.actions.push(Event:SendCompUCRespStale);
    tbe.actions.push(Event:WaitCompAck);
  } else {
    // must be the only one in sharers map
    assert(tbe.dir_sharers.count() == 1);
    assert(tbe.dataUnique);

    // needed by UpdateDirState_FromReqResp triggered by the expected CompAck
    tbe.dataMaybeDirtyUpstream := true;
    tbe.requestorToBeExclusiveOwner := true;
    tbe.dir_ownerExists := false;

    tbe.actions.push(Event:SendCompUCResp);
    tbe.actions.push(Event:WaitCompAck);

    // Ensure we writeback or update the cache if the owner has data as
    // clean data and we have it dirty.
    tbe.actions.push(Event:MaintainCoherence);
  }
}

action(Initiate_MaintainCoherence, desc="") {
  // issue a copy back if necessary to maintain coherence for data we are
  // droping. This is should be executed at the end of a transaction
  assert(tbe.actions.empty());
  // go through either the fill or the writeback pipeline
  if (tbe.dataValid && tbe.dataToBeInvalid) {
    // we don't need to WB if the upstream is SD, because the
    // owner is responsible for the WB
    bool has_non_ex_owner := tbe.dir_ownerExists && !tbe.dir_ownerIsExcl;
    if (is_HN && tbe.dataDirty && !has_non_ex_owner) {
      tbe.actions.push(Event:SendWriteNoSnp);
      tbe.actions.push(Event:SendWBData);
    }
  }
}

action(Send_WBData, desc="") {
  assert(is_valid(tbe));
  if (is_HN) {
    assert(tbe.dataBlkValid.isFull());
    assert(tbe.dataDirty);
    assert(tbe.dataValid);
    tbe.snd_msgType := CHIDataType:NCBWrData;
  }
  tbe.snd_destination := mapAddressToDownstreamMachine(tbe.addr);
  setupPendingSend(tbe);
}

// Retry related
action(Send_RetryAck, desc="") {
  peek(retryTriggerInPort, RetryTriggerMsg) {
    enqueue(rspOutPort, CHIResponseMsg, response_latency) {
      out_msg.addr := in_msg.addr;
      out_msg.usesTxnId := in_msg.usesTxnId;
      out_msg.type := CHIResponseType:RetryAck;
      out_msg.responder := machineID;
      out_msg.Destination.add(in_msg.retryDest);
    }
  }
}

action(Send_PCrdGrant, desc="") {
  peek(retryTriggerInPort, RetryTriggerMsg) {
    enqueue(rspOutPort, CHIResponseMsg, response_latency) {
      out_msg.addr := in_msg.addr;
      out_msg.usesTxnId := in_msg.usesTxnId;
      out_msg.type := CHIResponseType:PCrdGrant;
      out_msg.responder := machineID;
      out_msg.Destination.add(in_msg.retryDest);
    }
  }
}

action(Pop_RetryTriggerQueue, desc="") {
  retryTriggerInPort.dequeue(clockEdge());
}

// SnoopFilter related actions 
action(StallRequest_OnSnoopFilterRepl, desc="") {
  // A valid tbe is not yet allocated. But must stall
  stall_and_wait(reqRdyPort, address);
}

action(Initiate_SnoopFilterReplacement, desc="") {
  assert(is_invalid(tbe));
  DirEntry dir_entry := getDirEntry(address);
  assert(is_valid(dir_entry));
  State initial := getState(tbe, address);
  peek(sfReplInPort, SFReplMessage) {
    set_tbe(allocateSnoopFilterTBE(address, machineID, machineID));
    tbe.evicting_sf_addr := in_msg.toAddr;
  }
  copyDir(dir_entry, tbe, initial);

  // Is this correct?
  incomingTransactionStart(address, curTransitionEvent(), initial, false);
}

action(Initiate_SnoopFilterReplacement_WB_BackInv, desc="") {
  assert(is_HN);
  assert(is_valid(tbe));
  assert(tbe.dataDirty || tbe.dataMaybeDirtyUpstream);
  tbe.doCacheFill := false;
  tbe.actions.push(Event:SendSnpCleanInvalid);
  tbe.actions.push(Event:SnoopFilterHAWB);
}

action(Initiate_SnoopFilterReplacement_Evict_BackInv, desc="") {
  assert(is_HN);
  assert(is_valid(tbe));
  tbe.actions.push(Event:SendSnpCleanInvalid);
  tbe.dataToBeInvalid := true;
  tbe.actions.push(Event:ResetAndDeallocDirEntry); // pushNB?
  tbe.actions.push(Event:WakeUpEvictingSnoopFilterAddr); // pushNB?
}

action(StallSnoopFilterEviction, desc="") {
  // was stalled because of an existing request
  assert(is_valid(tbe));
  assert(tbe.addr == address);
  tbe.wakeup_pending_sfRepl := true;
  stall_and_wait(sfReplInPort, address);
}

action(Profile_SnoopFilterMiss, desc="") {
  assert(is_valid(tbe)); // Why is this necessary?
  directory.profileMiss();
}

action(Pop_SFReplTriggerQueue, desc="") {
  sfReplInPort.dequeue(clockEdge());
}

action(Send_SnpCleanInvalid, desc="") {
  assert(is_valid(tbe));
  assert(tbe.expected_snp_resp.hasExpected() == false);
  // at least one sharer or owner othrwise should not execute this
  assert(tbe.dir_sharers.count() > 0);
  enqueue(snpOutPort, CHIRequestMsg, snoop_latency) {
    prepareRequest(tbe, CHIRequestType:SnpCleanInvalid, out_msg);
    out_msg.Destination.addNetDest(tbe.dir_sharers);
    out_msg.retToSrc := false;
  }
  setExpectedForInvSnoop(tbe, false);
}

action(StallRequest_OnSnoopFilterRepl_Pend, desc="") {
  // Directory(set,way) is busy servicing other SFRepl requests. Create a Stall for this request
  stall_and_wait(reqRdyPort, address);
  snoopFilterPendQ.emplace_sfrepl(address);
}

action(Reset_DirEntry, desc="") {
  assert(is_valid(tbe));
  assert(tbe.addr == address);
  resetDirEntryAndWakeupPendingSFRepl(address);
}

action(Deallocate_DirEntry, desc="") {
  assert(directory.isTagPresent(address));
  directory.deallocate(address);
}