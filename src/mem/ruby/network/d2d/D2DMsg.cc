/**
 * Copyright Starfive Pvt Ltd 2023
 */

#include <iostream>
#include <memory>
#include <typeinfo>
#include <cxxabi.h>

#include "mem/ruby/network/d2d/D2DMsg.hh"
#include "mem/ruby/system/RubySystem.hh"
#include "mem/ruby/protocol/CHIRequestMsg.hh"
#include "mem/ruby/protocol/CHIResponseMsg.hh"
#include "mem/ruby/protocol/CHIDataMsg.hh"
#include "debug/RubyD2DStr5.hh"

namespace gem5
{

	namespace ruby
	{

		int D2DMsg::NUM_VNETS = 4;

		const std::string demangle(const std::type_info& msg_type) {
			const char* name = msg_type.name();
			int status = -4;
			char* res = abi::__cxa_demangle(name, NULL, NULL, &status);
			const char* const demangled_name = (status==0)?res:name;
			std::string ret_val(demangled_name);
			free(res);
			return ret_val;
		}

		bool isSnpReqType(const CHIRequestMsg *in_msg_req) {
			/**
			 * The CHI states are generated by SLICC
			 * so this approach is not scalable
			 */ 
			const CHIRequestType& type =  in_msg_req->gettype();
			if ((type == CHIRequestType_SnpSharedFwd) ||
					(type == CHIRequestType_SnpNotSharedDirtyFwd) ||
					(type == CHIRequestType_SnpUniqueFwd) ||
					(type == CHIRequestType_SnpOnceFwd) ||
					(type == CHIRequestType_SnpOnce) ||
					(type == CHIRequestType_SnpShared) ||
					(type == CHIRequestType_SnpUnique) ||
					(type == CHIRequestType_SnpCleanInvalid) ||
					(type == CHIRequestType_SnpDvmOpSync_P1) ||
					(type == CHIRequestType_SnpDvmOpSync_P2) ||
					(type == CHIRequestType_SnpDvmOpNonSync_P1) ||
					(type == CHIRequestType_SnpDvmOpNonSync_P2)) {
				return true;
			} else {
				return false;
			}
		}

		/** \brief Print the state of this object */
		void
			D2DMsg::print(std::ostream& out) const
			{
				out << "[D2DMsg: ";
				for (auto it = m_msgptrvec.begin(); it != m_msgptrvec.end(); it++) {
					out << *(it->second) << "\n";
				}
				out << "]";
			}   

		void D2DMsg::extractCHIMessages(Tick curTick, std::vector<std::vector<MsgPtr>> &chi_msg_from_d2d) const {

			int vnet_id = -1;

			panic_if(chi_msg_from_d2d.size() != NUM_VNETS, "The D2DMsg container is malformed\n");

			panic_if(m_msgptrvec.size() <= 0, "Trying to extract chi flits from empty d2d flits\n");

			for (auto it = m_msgptrvec.begin(); it != m_msgptrvec.end(); it++) {
				vnet_id = it->first;
				const Message* msg = (it->second).get();
				const std::type_info& msg_type = typeid((it->second).get());
				panic_if(vnet_id < 0,"Illegal vnet_id = %d, type_name=%s\n",vnet_id,demangle(msg_type));
				switch(vnet_id) {
					case 0 : 
					case 1 : /* REQ or SNP */ {
									  const CHIRequestMsg* in_msg_ptr =  dynamic_cast<const CHIRequestMsg *>(msg);
									  panic_if(in_msg_ptr == nullptr,"Cannot cast to CHIRequestMsg");
									  panic_if(isSnpReqType(in_msg_ptr) && vnet_id != 1, "Invalid vnet for snp CHIRequestMsg, %s\n",demangle(msg_type));
									  std::shared_ptr<CHIRequestMsg> out_msg = std::make_shared<CHIRequestMsg>(curTick);
									  *out_msg = (*in_msg_ptr);
									  chi_msg_from_d2d[vnet_id].push_back(out_msg);
									  break;
								  }
					case 2 : /* RSP */ {
								   const CHIResponseMsg* in_msg_ptr =  dynamic_cast<const CHIResponseMsg *>(msg);
								   panic_if(in_msg_ptr == nullptr,"Cannot cast to CHIResponseMsg, %s\n",demangle(msg_type));
								   std::shared_ptr<CHIResponseMsg> out_msg = std::make_shared<CHIResponseMsg>(curTick);
								   *out_msg = (*in_msg_ptr);
								   chi_msg_from_d2d[vnet_id].push_back(out_msg);
								   break;
							   }
					case 3 : /* DAT */ {
								   const CHIDataMsg* in_msg_ptr =  dynamic_cast<const CHIDataMsg *>(msg);
								   panic_if(in_msg_ptr == nullptr,"Cannot cast to CHIDataMsg, %s\n",demangle(msg_type));
								   std::shared_ptr<CHIDataMsg> out_msg = std::make_shared<CHIDataMsg>(curTick);
								   *out_msg = (*in_msg_ptr);
								   chi_msg_from_d2d[vnet_id].push_back(out_msg);
								   break;
							   }
				}
				push_heap(chi_msg_from_d2d[vnet_id].begin(), chi_msg_from_d2d[vnet_id].end(), std::greater<MsgPtr>());
			}

		}

	} // namespace ruby
} // namespace gem5
